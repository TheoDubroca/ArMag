---
title: "Test Code ArMag"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r pour creer un racourcie }
#shinyShortcut(shinyDirectory = "~/Documents/AM/R_Projects/ArMag/Visu_AM", OS = "unix",   gitIgnore = FALSE)
```

# Chargement des fonctions d'ArMag via GitHub
```{r echo = TRUE}

if (!require(devtools))
 {install.packages("devtools")}

devtools::install_github("chrono35/ArMag", force = TRUE)
library("ArMag") #, lib.loc="/Library/Frameworks/R.framework/Versions/3.5/Resources/library")
```

# Chargement des fonctions d'ArMag via source
Si besoin
```{r echo = TRUE}
# source('R/ArMag.R', echo=FALSE)

```

# Chargement fichier test avec fonction read.Pal




## Lecture fichier pal
```{r test read.Pal}
#file.AM <- "~/Documents/AM/GDRE1_INT.AMD"
# file.AM <- "/Volumes/Partage_Mesures_Archeomag/Mesures/22061_Glomel/22061A.AMD"
# file.AM <- "~/Documents/AM/22061_Glomel/22061A.AMD"
#file.AM <- "~/Documents/AM/53130_Laval/53130_Mesures/53130B1_2019.AMD"
#file.Pal <- "~/Documents/AM/Agnes&Maria/Portugal.txt"
file.Pal <- "examples/Portugal.txt"

mes <- NULL
mes <- read.Pal.mesures(file.Pal)
mes.info <- read.Pal.info (file.Pal)

desaim(mes)

# export en csv
#write.csv(mes, file = "~/Documents/AM/Agnes&Maria/Portugal.csv")
```

```{r}
# calcul de l'anisotropie moyenne
ani.moyen <- anisotropy.mean.eigen.tensor(mes, mes.info$number[1:20], step.value = 480, step.code = c("Z+", "Z-", "X+", "X-", "Y+", "Y-", "ZB"))

# calcul et stockage des anisotropies individuelles
ani.all.spe <- anisotropy.eigen.tensors.all(mes, mes.info$number[1:20], step.value = 480, step.code = c("Z+", "Z-", "X+", "X-", "Y+", "Y-", "ZB"))
ani.all.spe.mane <- cbind(mes.info$name[1:20], ani.all.spe)
```

```{r affichage anisotropie moyenne}
#png(paste(TeX.floder,"22061A_ANI.png", sep = "") , bg = "transparent", width = 1000) # Directement dans le dossier TeX
#par(mfrow = c(1, 2)) # pour exportation

par(mfrow = c(1, 2), cex.axis = 0.5)

lambert.ID.tensors(ani.all.spe)
lambert.ID.tensors(ani.moyen, pt.col = "red", new = FALSE)

flinn(ani.all.spe)
flinn(ani.moyen, pt.col = "red", new = FALSE)

# dev.off() # fin sauvegarde-exportation
```

# Chargement fichier test avec fonction read.AM

## Test execution
```{r test read.AM}
# file.AM <- "~/Documents/AM/GDRE1_INT.AMD"
# file.AM <- "/Volumes/Partage_Mesures_Archeomag/Mesures/22061_Glomel/22061A.AMD"
# file.AM <- "~/Documents/AM/22061_Glomel/22061A.AMD"
 file.AM <- "examples/14039C.AMP"
# file.AM <- "~/Documents/AM/Aire/40001A.AMD"

mes <- NULL
mes <- read.AM.mesures(file.AM)
mes.info <- read.AM.info (file.AM)
```


```{r test mcFadden}

select <- NULL
select$I <- mes$I[mes$step.value== 0]
select$D <- mes$I[mes$step.value== 0]

stat.mcFadden(select$I[1:8], select$D[1:8])


#lambert(mes, inc.lim = c(0,90))
```


# Codage correction anisotropie
```{r}
# calcul les nouveaux paramètres d'un echantillon avec un tenseur donnée
#procedure Calcul_Aniso_Specimen(var R_Cal_echt:Res_Cal_xyz;Tens_ani:TENSEUR_ANISO );
mes.sel <- NULL
mes.sel1 <- extract.mesures.specimen.name("14P2", mes)

volume <- mes.info$vol[which(mes.info$name == trimws(mes.sel1$name[1]))]
TH <- mes.info$TH[which(mes.info$name == trimws(mes.sel1$name[1]))]
mes.sel1$X <- mes.sel1$X/volume * 1E6
mes.sel1$Y <- mes.sel1$Y/volume * 1E6
mes.sel1$Z <- mes.sel1$Z/volume * 1E6
ani1 <- anisotropy.matrix.symetric(mes.sel1, step.value = 550, TH = TH, volume = volume )

mes.sel2 <- extract.mesures.specimen.name("16P1", mes)
volume <- mes.info$vol[which(mes.info$name == trimws(mes.sel2$name[1]))]
TH <- mes.info$TH[which(mes.info$name == trimws(mes.sel2$name[1]))]
ani2 <- anisotropy.matrix.symetric(mes.sel2, step.value = 550, TH = TH, volume = volume )

mes.sel3 <- extract.mesures.specimen.name("24P1", mes)
volume <- mes.info$vol[which(mes.info$name == trimws(mes.sel3$name[1]))]
TH <- mes.info$TH[which(mes.info$name == trimws(mes.sel3$name[1]))]
ani3 <- anisotropy.matrix.symetric(mes.sel3, step.value = 550, TH = TH, volume = volume )


mes.sel4 <- extract.mesures.specimen.name("15P1", mes)
volume <- mes.info$vol[which(mes.info$name == trimws(mes.sel4$name[1]))]
TH <- mes.info$TH[which(mes.info$name == trimws(mes.sel4$name[1]))]
ani4 <- anisotropy.matrix.symetric(mes.sel4, step.value = 550, TH = TH, volume = volume )


mes.sel.ARN <- mes[mes$step.value == 0,]
mes.sel.ARN$X <- mes.sel.ARN$X /volume * 1E6
mes.sel.ARN$Y <- mes.sel.ARN$Y/volume * 1E6
mes.sel.ARN$Z <- mes.sel.ARN$Z/volume * 1E6

ani <- anisotropy.matrix.symetric(mes, step.value = 550)
ani.tens <- anisotropy.eigen.tensor(mes, step.value = 550 ) # eigen.tensor

# matrice moyenne
  ani.mean <- (ani2+ ani3 + ani4)/3
  eigen(ani.mean)
```



# test correction.anisotropie
```{r}
mes.sel <- NULL
mes.sel <- extract.mesures.specimen.name("24P1", mes)
volume <- mes.info$vol[which(mes.info$name == trimws(mes.sel$name[1]))]
TH <- mes.info$TH[which(mes.info$name == trimws(mes.sel$name[1]))]

mes.sel.ARN <- mes.sel[mes.sel$step.value == 0,]
mes.sel.ARN$X <- mes.sel.ARN$X /volume * 1E6
mes.sel.ARN$Y <- mes.sel.ARN$Y /volume * 1E6
mes.sel.ARN$Z <- mes.sel.ARN$Z /volume * 1E6

ani <- anisotropy.matrix.symetric(mes.sel, step.value = 550, TH = TH, volume = volume )

# normalisation des mesures en A/m
mes.sel$X <- mes.sel$X /volume * 1E6
mes.sel$Y <- mes.sel$Y /volume * 1E6
mes.sel$Z <- mes.sel$Z /volume * 1E6
correction.anisotropy(mes.sel, ani)
```


# Tracer


```{r selection}
mes.ech <- NULL
mes.ech <- extract.mesures.specimen.name("10P1", mes)
  mes.ech <- remove.step(mes.ech, step.value = 550, step.code = c("??"))
   mes.ech <- remove.step(mes.ech, step.value = 400, step.code = c("??"))
#mes.sel2 <- extract.mesures.specimen.number(2, mes2)
```
## Tracer de Zijderveld
```{r fonction plot.zjiderveld1}
par(pty="s") # force une figure carré
zijderveld1(mes.ech$X, mes.ech$Y, mes.ech$Z) #, pt.name = mes.ech$Etap)
par(mfrow = c(1,2), pty="m", cex.lab = 0.5, cex.axis = 0.6) # séparation en 2 colonnes et rétablie une figure taille maximale
# cex.axis défini la taille du texte des échelles
# cex.lab défini la taille du texte des étapes 
zijderveld1(mes.ech, legend.pos = "topright")
zijderveld2(mes.ech, pt.names = NULL)
```

Nous devons obtenir la même chose. Chacune des fonction utilisant des paramètres différents
```{r comparatif fonction plot}

lambert.XYZ.specimen(mes.ech)
lambert.ID.specimen(mes.ech)
```

# Calcul sur matrice

```{r test extract.aniso}
volume <- mes.info$vol[which(mes.info$name == trimws(mes.sel$name[1]))]
TH <- mes.info$TH[which(mes.info$name == trimws(mes.sel$name[1]))]

ani <- anisotropy.matrix.symetric(mes.sel, step.value = 550, TH = TH, volume = volume )
ani
```



```{r}
TH <- 60
mes.sel <- NULL

mes.sel1 <- extract.mesures.specimen.number(1, mes)
mes.sel2 <- extract.mesures.specimen.number(2, mes)
mes.sel3 <- extract.mesures.specimen.number(3, mes)

ani1 <- anisotropy.eigen.tensor(mes.sel1, step.value = 550)
ani2 <- anisotropy.eigen.tensor(mes.sel2, step.value = 550 )
ani3 <- anisotropy.eigen.tensor(mes.sel3, step.value = 550 )

Data <- rbind(ani1, ani2, ani3)
lambert.ID.tensors(Data, point.col = c("blue", "red", "green"))

numbers <- c(7)
Data <- anisotropy.eigen.tensors.numbers(numbers, mes, mes.info, 400)
lambert.ID.tensors(Data, point.col = c("blue", "red", "green"))


numbers.selected <- NULL
  for (i in 1: length(mes$number) ) {
    if ( length(which( numbers.selected == mes$number[i] )) == 0 )
      numbers.selected <- c(numbers.selected, mes$number[i])
  }

```


```{r test plot.flin }
flinn(Data)#, points.col = c("red", "blue"), pt.names = c("titi", "toto"))

```

```{r codage desaimantation}
mes.seltt <- NULL
mes.seltt <- rbind(mes.sel1, mes.sel2)

 
```




```{r}
mes.sel2 <- extract.mesures.specimen.name("1P1", mes)
mes.sel3 <- extract.mesures.specimen.name("16P1", mes)
desaim(mes.sel2, etap.J0 = NULL)
desaim(mes, etap.J0 = 0, pt.col = rainbow(length(mes.info$name)))
desaim(rbind(mes.sel2, mes.sel3), normalize = TRUE)

partial.component(mes.sel2$X, mes.sel2$Y, mes.sel2$Z)
```

```{r assemblé}

par(mfrow = c(2, 2), cex.lab = 0.7, cex.axis = .7, cex = 0.7, cex.main = 1, cex.sub = 0.1,
    mai = c(0.5, 0.5, 0.7, 0.3), oma = c(0, 1, 1, 1))#, pty ="s" )
zijderveld1.T1T2(mes.sel2)
zijderveld2.T1T2(mes.sel2)

# suppression des étapes d'anisotropie
mes.sel2 <- remove.step(mes.sel2) 
lambert(mes.sel2, inc.lim = c(0, 90))
desaim(mes.sel2, etap.J0 = NULL)
```





```{r genere AMD}
file.AM <- "examples/test.txt"
list.ech <- c("1T",   "17T",  "35T",  "47T",  "50T",  "59T",  "83T",  "87T",  "89T",  "94T",  "100T", "102T", "103T" )
genere.AMD(file.AM, list.ech)
```



# Calcul vecteur partiel





```{r composante de tout le site}
sp.res <- NULL
for (sp in 1: length(mes.info$number)){
  sp.mes <- extract.mesures.specimen.number(mes.info$number[sp], mes)


  # correction d'anisotropie
  volume <- mes.info$vol[which(mes.info$name == trimws(sp.mes$name[1]))]
  TH <- mes.info$TH[which(mes.info$name == trimws(sp.mes$name[1]))]
  
  # normalisation des mesures en A/m
  sp.mes$X <- sp.mes$X /volume * 1E6
  sp.mes$Y <- sp.mes$Y /volume * 1E6
  sp.mes$Z <- sp.mes$Z /volume * 1E6
  
  # récupération de l'ARN
  #sp.mes.ARN <- sp.mes[sp.mes$step.value == 0,]
  

  # évaluation de l'anisotropie
  sp.ani <- anisotropy.matrix.symetric(sp.mes, step.value = 550, TH = TH, volume = volume )
 # controle de l'existance de l'anisotropie
  if (!is.na(sum(sp.ani))) {
    # suppression des étapes d'anisotropie
    sp.mes <- remove.step(sp.mes) #, step.value = "0", step.code = "N") 
      
    # correction de l'anisotropie  
    sp.cor <- correction.anisotropy(sp.mes, sp.ani)
    
  } else {
    warning("No anisotropy step \n")
    sp.cor <- sp.mes
  }
  
  # determination de la composante
  sp.cp <- partial.component(sp.cor$X, sp.cor$Y, sp.cor$Z)
  
  # repliement
  sp.cp <- repliement.auto(sp.cp$I, sp.cp$D, name = sp.mes$name)
  sp.res <- rbind.data.frame(sp.res, cbind(name =mes.info$name[sp], sp.cp) )
}


stat.mcFadden(sp.res$I, sp.res$D)


lambert(sp.res, inc.lim = c(0,90))
```



# Calcul azimut du soleil
```{r}
JulianDay <- function(day, month, year, UT=12)
  # valid from 1900/3/1 to 2100/2/28 # http://jgiesen.de/elevazmoon/basics/meeus.htm
  # equivalent à la fonction dans R : julian(Sys.Date(), -2440588)
  # ISOdate(year, month, day, hour = 12, min = 0, sec = 0, tz = "GMT")
{
  #  if (month<=2) {
   #   month=month+12
   #   year=year-1
   #   }
    #return ( trunc(365.25*year) + trunc(30.6001*(month+1)) - 15 + 1720996.5 + day + UT/24.0 )
  return ( 367*year-7*trunc( (year+trunc((month+9)/12 ) )/4)+275*trunc(month/9)+day+1721014 ) # https://cral-perso.univ-lyon1.fr/labo/fc/cdroms/docu_astro/jour_julien/jour_julien.pdf
} 
```




```{r}
#sun.azimuth <- function(Day, Month, Year, Hour, Minute, Seconde=0, longdeg, longmin=0, longsec=0, latdeg, latmin=0, latsec=0, deviation = 0, tz = "UTC")
#{
#D:jour M:Month  Y:Year HH:Hour  NN:Minute KK:seconde
  #  DD:=longdeg;  FF:=longmin;  SS:=longsec;  ZZ:=latdeg;  YY:=latmin;  XX:=latsec;
#   les valeurs des degres minutes et secondes peuvent etre negatives dans la procedure}
# Pour la France tz = "Europe/Paris", calcul alors automatiquement le décalage horaire
  Day=13 ; Month=07; Year=1999; Hour=13; Minute=3; Seconde=0; 
longdeg=-1; longmin=40; longsec=21; 
latdeg=43; latmin=14; latsec=47; deviation = 0;
tz = "UTC"
  
cmp <- function(expres ) {
  if (expres == TRUE) {
    return(-1)
  } else {
    return(0)
  }
}

absTrunc <- function(x) {
  return(as.numeric(trunc(x)))
}

RAD <- pi/180
#LongNeg <- (longdeg<0)
#LatNeg <- (latded<0)
# modification des longitudes et latitudes 
#if(longdeg<0) {
#  longdeg =-abs(longdeg)
#          longmin = -longmin
##          longsec = -longsec
#}
    
 # LON = longdeg +(longmin /60)+(longsec/3600)
  LON <- DMS.to.DD(longdeg, longmin, longsec)

#  if( latdeg<0) {
#    latdeg=-Abs(latdeg)
#       latmin=-latmin
#       latsec=-latsec
#  } 
 # LAT = latdeg+ latmin/60+ latsec/3600;
  LAT <- DMS.to.DD(latdeg, latmin, latsec)

 # if ( (Month=1) | (Month=2)){
#    Year = Year-1
 #   Month = Month+12
 # } 
 # A = absTrunc(Year/100)
 # B = 2 - A + absTrunc(A/4)
 # J = absTrunc(365.25*Year) + absTrunc(30.6001*(Month+1)) + Day + 1720995 + B -0.5

  H = Hour + Minute/60 +Seconde/3600
 # J1 = J + H/24
 
  #J <- trunc(365.25*Year) + trunc(30.6001*(Month+1)) - 15 + 1720996.5 + Day 
  J1 <- calcul_jour_julien(Day, Month, Year, heure =  Hour, Minute, Seconde) 
  
 # J1 <- julian(as.Date(ISOdatetime(year = Year, month = Month, day = Day, hour = Hour, min = Minute, sec = Seconde, tz = tz)), -2440588)
  
  Ta = (J1-2.41502E+06)/36525
  EX = 0.01675104-0.0000418*Ta
  EP = 23.45229444-0.013012*Ta
  L1 = 279.696678+36000.76892*Ta
  L = (L1/360- abs(L1/360))*360
  M1 = 358.4758445+35999.04975*Ta
  MPrim = (M1/360- abs(M1/360))*360
  MR = MPrim*RAD
  VR = MR + 2*EX*sin(MR) + (5*EX*EX*sin(2*MR)/4) + (EX*EX*EX)*( (13*sin(3*MR)/12)- sin(MR)/4)
  V = VR*180/pi
  OM = 259.18-1934.14*Ta
  L2 = L+V-MPrim - 0.00569- 0.00479*sin(OM*RAD)
  K = cos(EP*RAD)*cos(L2*RAD)/cos(L2*RAD)
  ALF = atan(K)
  if ((Month>5) & (Month<13)) {
    ALF = ALF + (cmp(K<0)*cmp(Month<10)+cmp(K>0)*cmp(Month>8))*pi
  }
  Q = sin(EP*RAD)*sin(L2*RAD)
  DELT = atan(Q/sqrt(1-Q*Q))
  DEC = DELT*180/pi
  ALFA = ALF*180/pi
  T1 = (J-2.41502E+06)/36525;
  # TSL = Temps sideral local en heure décimale }
  PT = 1.05*sin(OM*RAD)/3600;
  PR = (0.08*sin((199-72002*T1)*RAD))/3600
  TSL = 6.64079 +2400.051278*T1+ (0.095*(T1^2)/3600) - PT-PR+ LON/15+ H*1.0027379
  TSL = TSL-24*absTrunc(TSL/24)
  
  AH = TSL-ALFA/15
  R = sin(AH*15*RAD)/(sin(LAT*RAD)*cos(AH*15*RAD)-cos(LAT*RAD)*atan(DEC*RAD))
  AZ = atan(R)*180/pi
  AZ = AZ+180
  if(AH<0) {
    AH = AH+24
  } 
  AH = AH -24*absTrunc(AH/24)
  
  # AZ : azimut du soleil 
  if ((AH>12) & (AZ>180)) 
    AZ= AZ+180
  if ((AH<12) & (AZ<180))
    AZ = AZ+180  

  if (deviation>=0) {
    deviation = deviation + (AZ-360)*RAD
  } else deviation = deviation + AZ*RAD

  deviation <- deviation/RAD
#return(deviation)
#}
```


```{r}
# Le jour julien 0 commence le 24 novembre -4713 (4712 BC) à 12h
#' Le nombre de jour julien pour les calculs astronomiques
#' @seealso \code{\link{https://codes-sources.commentcamarche.net/source/31774-calcul-de-la-position-du-soleil-declinaison-angle-horaire-altitude-et-azimut-altaz-solaire}}
#' @export
jour.julien <- function( jour,   mois,   annee,   heure,   minute,   seconde)
{
        day <- jour + heure/24 + minute/1440 + seconde/86400
        year <- annee
        month <- mois

        if (month == 1 || month == 2)
        {
                year <- year-1
                month <- month+12
        }

        a <- trunc(year/100)
        b <- 2 - a + trunc(a/4)

        jour_julien <- trunc(365.25*(year+4716)) + trunc(30.6001*(month+1)) + day + b - 1524.5
        
        return (as.numeric(jour_julien))
}
```

```{r juju}
juju <- function( jour,   mois,   annee)
{
            jour_julien <- (1461 * (annee + 4800 + (mois - 14)/12))/4 +(367 * (mois - 2 - 12 * ((mois - 14)/12)))/12- (3 * ((annee + 4900 + (mois - 14)/12)/100))/4 + jour - 32075.0
        return (as.numeric(jour_julien) )
}
```


```{r}
# https://codes-sources.commentcamarche.net/source/31774-calcul-de-la-position-du-soleil-declinaison-angle-horaire-altitude-et-azimut-altaz-solaire

# Pour controler
# https://www.sunearthtools.com/dp/tools/pos_sun.php?lang=fr
# https://fr.planetcalc.com/320/

jour2= 28 ; mois2= 04; annee2= 1994; heure2= 12; minute2= 51; seconde2= 10
longitude= 20; longmin= 20; longsec= 46    # Est est positif, et Ouest est négatif
latitude= 50; latmin= 41; latsec= 53; deviation = 0
tz = "UTC"
sun.azimuth(jour2, mois2, annee2, heure2, minute2, seconde2, longitude, longmin, longsec, latitude, latmin, latsec)
360-sun.azimuth(jour2, mois2, annee2, heure2, minute2, seconde2, longitude, longmin, longsec, latitude, latmin, latsec)
```



```{r test sun.azimuth}

sun.azimuth (10, 11, 2019, 11, 19, Seconde=0, 48, longmin=0, longsec=0, 45, latmin=0, latsec=0)

```


# test igrf13syn
```{r}
isv <- 1
date <- 2000
itype <- 1
alt <- 50
colat <- 90 - 45
elong <- 10

igrf13syn(isv=isv, date=date, itype=itype , alt=alt, colat= colat, elong=elong)
```

# Vieux fichier


```{r read.AM.oldType.mesures}
file.AM <- "examples/old-type.AMD"
oldType.file.info <- read.AM.oldType.info(file.AM, encoding = "macroman")
oldType.file <- read.AM.oldType.mesures(file.AM, encoding = "macroman")

```

# test codage diagramme ARAI
```{r}
file.INT <- "examples/INT_example.AMD"

mesINT <- NULL
mesINT <- read.AM.mesures(file.INT)
mesINT.info <- read.AM.info (file.INT)
mes.sel<- extract.mesures.specimen.name("40001B_11B1", mesINT)
```

```{r}
# reference 
# Coe 1978 : DOI: 10.1029/JB083iB04p01740
# Prévost et Al. 1985 DOI: 10.1029/JB090iB12p10417
par(pty="s", "xaxp")
relative = FALSE
verbose = TRUE
show.plot = TRUE
vol=10.8
TH = 60
aim.coef = 1E-10*1E6/vol #1E6
show.step.value = FALSE
R.mark = 'R'  # Positive pTRM
V.mark = 'V'  # Negative pTRM
P.mark = 'P'  # pTRM check
L.mark = "L"  # sLow cooling 
Q.mark = "Q"  # Quick cooling
pt.col = "blue"
loop.col = "forestgreen"
step.J0 = "20N0" # ou NULL

begin.step.value = 0
end.step.value = 700

par(pty="s", "xaxp")
arai(mes.sel, begin.step.value = 250, end.step.value = 700, aim.coef = 1E-10*1E6/vol)

```

```{r arai}
arai <- function(mesures, relative = TRUE, verbose = TRUE, show.plot = TRUE, TH = 60, aim.coef = 1E-10*1E6, show.step.value = FALSE, R.mark = 'R', V.mark = 'V', P.mark = 'P', L.mark = "L", Q.mark = "Q", pt.col = "blue", loop.col = "forestgreen", step.J0 = "20N0", begin.step.value = 0, end.step.value = 1000) {
# __________________
if (is.null(step.J0)) {
  step.J0 <- mes.sel$step[1]
}

ATRR <- mesures[which(substr(mesures$step, nchar(mesures$step)-1, nchar(mesures$step)-1 ) == R.mark),]
ATRV <- mesures[which(substr(mesures$step, nchar(mesures$step)-1, nchar(mesures$step)-1 ) == V.mark),]

J0 <- mesures [which(trimws(mesures$step) ==trimws(step.J0) ), ]
if (J0$F < 0 ) {
  warning("error on step.J0, F must be positive")
  
} else {
  ATRR <- rbind.data.frame(J0, ATRR)
  ATRV <- rbind.data.frame(J0, ATRV)
}

for (i in 1:length(ATRR$step) ) {
  ATRR$step.name[i] <- substr(ATRR$step[i], nchar(ATRR$step[i]), nchar(ATRR$step[i]) )
}
for (i in 1:length(ATRV$step) ) {
  ATRV$step.name[i] <- substr(ATRV$step[i], nchar(ATRV$step[i]), nchar(ATRV$step[i]) )
}


ARN <- NULL
ATR <- NULL
RN <- NULL
TR <- NULL
pt.col.res <- NULL
# tableau ATR vs ARN
for (i in ATRR$step.name) {
  iATRR <- which(ATRR$step.name == i)
  iATRV <- which(ATRV$step.name == i)
  
  atrXR <- ATRR[iATRR, ]$X *aim.coef
  atrXV <- ATRV[iATRV, ]$X *aim.coef
  
  atrYR <- ATRR[iATRR, ]$Y *aim.coef
  atrYV <- ATRV[iATRV, ]$Y *aim.coef
  
  atrZR <- ATRR[iATRR, ]$Z *aim.coef
  atrZV <- ATRV[iATRV, ]$Z *aim.coef
  
  if (ATRR[iATRR, ]$step.value != ATRV[iATRV, ]$step.value) {
    warning(paste0("Error in step.name within step.value = ", ATRR[iATRR, ]$step, ATRV[iATRV, ]$step) )
    next
  }
  
  RN$X <- (atrXR + atrXV)/2
  RN$Y <- (atrYR + atrYV)/2
  RN$Z <- (atrZR + atrZV)/2
  
  RN <- to.polar(RN$X, RN$Y, RN$Z)
  RN$step.value <- ATRR[iATRR, ]$step.value
  RN$step.name <- i
 
  ARN <-rbind.data.frame(ARN, RN, stringsAsFactors = FALSE)
  
  TR$X <- (atrXR - atrXV)/2
  TR$Y <- (atrYR - atrYV)/2
  TR$Z <- (atrZR - atrZV)/2
  TR <- to.polar(TR$X, TR$Y, TR$Z)
  TR$step.value <- ATRR[iATRR, ]$step.value
  TR$step.name <- i
  
  ATR <-rbind.data.frame(ATR, TR, stringsAsFactors = FALSE)
 if ((RN$step.value >= begin.step.value) && (RN$step.value <= end.step.value)) {
   pt.col.res <- c(pt.col.res, "red")
 } else {
   pt.col.res <- c(pt.col.res, pt.col)
 }
}
xlim <- range(ATR$F)
ylim <- range(ARN$F)

if (relative == TRUE) {
  ATRmax <- max(ATR$F) / 100
  ARNmax <- max(ARN$F) / 100
} else {
  ATRmax <- 1
  ARNmax <- 1
}

# Plot Arai
if (show.plot == TRUE) {
  
  xlim <- range(ATR$F/ATRmax)
  ylim <- range(ARN$F/ARNmax)
  if (relative == TRUE) {
    xlab <- "% ATR"
    ylab <- "% ARN"
  } else {
    xlab <- "ATR"
    ylab <- "ARN"
  }

  plot(y = ARN$F/ARNmax, x = ATR$F/ATRmax, type='o', col = pt.col.res, pch = 20, xlim = xlim, ylim = ylim, xlab = xlab, ylab = ylab)
  if (show.step.value == TRUE) {
    text(y= ARN$F, x=ATR$F, ARN$step.value, adj = 0)
  }
}

# stat with all points
Xmoy <- mean(ATR$F) 
Ymoy <- mean(ARN$F) 
n <- length(ATR$F)  

# calcul with a population, not with a sample
covYX <- cov(ATR$F, ARN$F) * (n-1)/n 
S2x <- var(ATR$F) * (n-1)/n 
S2y <- var(ARN$F) * (n-1)/n 

a_tot <- -sqrt(S2y/S2x)
b_tot <- Ymoy - a_aff*Xmoy
JTRM <- (-b_tot/a_tot)

# loop pTRM check
ATRP <- mesures[which(substr(mesures$step, nchar(mesures$step)-1, nchar(mesures$step)-1 ) == P.mark),]
for (i in 1:length(ATRP$step) ) {
  ATRP$step.name[i] <- substr(ATRP$step[i], nchar(ATRP$step[i]), nchar(ATRP$step[i]) )
}

# Plot loop
TP <- NULL
ATP <- NULL
for (i in ATRP$step.name) {
  iATRV <- which(ATRV$step.name == i)
  iATRP <- which(ATRP$step.name == i)
  
  atrXV <- ATRV[iATRV, ]$X *aim.coef
  atrXP <- ATRP[iATRP, ]$X *aim.coef
  
  atrYV <- ATRV[iATRV, ]$Y *aim.coef
  atrYP <- ATRP[iATRP, ]$Y *aim.coef
  
  atrZV <- ATRV[iATRV, ]$Z *aim.coef
  atrZP <- ATRP[iATRP, ]$Z *aim.coef
  
  
  TP$X <-(atrXP - atrXV)/2
  TP$Y <- (atrYP - atrYV)/2
  TP$Z <- (atrZP - atrZV)/2
  TP <- to.polar(TP$X, TP$Y, TP$Z)
  TP$step.value <- ATRP[iATRP, ]$step.value
  TP$step.name <- i
  
  ATP <-rbind.data.frame(ATP, TP, stringsAsFactors = FALSE)
  
  arnLoop.name <- ARN[which(ARN$step.name == i), ]
  arnLoop.value <- ARN[which(ARN$step.value == TP$step.value), ]
  atrLoop <- ATR[which(ATR$step.name == i), ]
  if (show.plot == TRUE) {
    points( x= TP$F/ATRmax, y= arnLoop.value$F/ARNmax, col = loop.col, pch = 4)
    lines( x= c(atrLoop$F/ATRmax, TP$F/ATRmax, TP$F/ATRmax), y = c(arnLoop.name$F/ARNmax, arnLoop.name$F/ARNmax, arnLoop.value$F/ARNmax), col = loop.col)
  }
}

res<- NULL
res$ARN <- ARN
res$ATR <- ATR
res$ATP <- ATP

# Statistic 

n <- 0
Crm <- CrmMax <- 0
tabX <- NULL
tabY <- NULL
for (i in 1:length(ARN$step.name))  {
  if ((ARN$step.value[i] >= begin.step.value) && (ARN$step.value[i] <= end.step.value)) {
    tabX <- c( tabX, ATR[which(ATR$step.value == ARN$step.value[i]),]$F  /ATRmax)
    tabY <- c( tabY, ARN$F[i]  /ARNmax)
     n <- n+1
     
     if (n==1) {
       incl_ET1.rad <- ARN$I[i]/180*pi
     } else {
        Crm <- ( sin( incl_ET1.rad -ARN$I[i]/180*pi) /sin(incl_ET1.rad -pi/2))*ARN$F[i]
        if (abs(Crm)>CrmMax) {
          CrmMax <- abs(Crm)
        } 
     }
   
    
  }
}
CrmMax <- CrmMax/ ( tabX[length(tabX)] - tabX[1])*100

if (n >= 2) {
  Xmoy <- mean(tabX) 
  Ymoy <- mean(tabY) 
  
  # calcul sur une population, pas sur un echantillon
  covYX <- cov(tabY, tabX) * (n-1)/n 
  S2x <- var(tabX) * (n-1)/n 
  S2y <- var(tabY) * (n-1)/n 

  a_aff <- -sqrt(S2y/S2x)
  b_aff <- Ymoy - a_aff*Xmoy
  
  abline(b_aff, a_aff, col= "red")
  
  # Calcul du coef. de corrélation linéaire de la droite entre les 2 étapes
  R <- cor(tabY, tabX) 
 
  # calcul de la variance eq n°3 : Prévost et Al. 1985 DOI: 10.1029/JB090iB12p10417

  s <-  covYX/sqrt(S2x*S2y)
  if (s < -1) {
     warning('Error on sigma Prévost =', s);
      s<- abs(s);
     
  } else {
       s <- sqrt( 2+(2*s));
       sigmaPrevost85 <- s/sqrt(n-2);
       # Calcul de sigma pour Coe 1978 : DOI: 10.1029/JB083iB04p01740
       sigmaCoe <- ((2*S2y)-2*a_aff*covYX) /((n-2)*S2x)
       sigmaCoe <- sqrt(sigmaCoe)
     
  } 
  # fraction of pTRM used
  fs1s2 <- function(tx,ty, i1, i2) {
    (a_aff*tabX[i1] + b_aff  + tabY[i1] )/2 - (a_aff*tabX[i2] + b_aff + tabY[i2])/2 
  }
  
  nStep <- length(tabX)
  # Coe et Al. 1978)
  fCoe78 <- fs1s2(tabX*ATRmax, tabY*ATRmax, 1, nStep) /b_aff
  
  g<-0
  for (i in 2:length(tabX)) {
    g <- g + fs1s2(tabX*ATRmax, tabY*ATRmax, i-1, i)^2
  }
  g <- 1 - g/(fCoe78*b_aff)^2
  
  qCoe78 <- abs(a_aff)*fCoe78*g/sigmaCoe;
  
  qPrevost85 <- fCoe78*g/sigmaCoe
  
  SigFe <- sigmaCoe*TH
  Fe <- -a_aff*TH
    
  if (verbose == TRUE) {
    Commentaire <- paste0('Coef. Corr. lin. R= ', format(R, digits = 3), ' pour ', n,' points')
    Commentaire <- c(Commentaire, paste0(' Sigmab ( Coe 1978) = ',format(sigmaCoe, digits = 3)) )
    Commentaire <- c(Commentaire, paste0('with lab field : ', TH, ' µT => Fe= ', format(Fe, digits = 3), ' ± ', format(SigFe, digits = 3), ' µT (Coe et Al. 1978)') )
    Commentaire <- c(Commentaire, paste0('f = ', format(fCoe78*100, digits = 4), '% (Coe et Al. 1978)') )
    Commentaire <- c(Commentaire, paste0('q = ', format(qCoe78, digits = 3)) )
    Commentaire <- c(Commentaire, paste0('g  = ', format(g, digits = 3)) )
    Commentaire <- c(Commentaire, paste0('Crm  = ', format(CrmMax, digits = 4), ' (Coe 1984)') )
    
    
    Commentaire <- c(Commentaire, paste0('q (Prévost 85) = ', format(qPrevost85, digits = 3)) )
    Commentaire <- c(Commentaire, paste0('sigma (Prévost 85) = ', format(sigmaPrevost85, digits = 3)) )
     print(Commentaire)           
  }
  
  # Cooling rate
  # slow step
  ATRL <- mes.sel[which(substr(mes.sel$step, nchar(mes.sel$step)-1, nchar(mes.sel$step)-1 ) == L.mark),]
  for (i in 1:length(ATRL$step) ) {
    ATRL$step.name[i] <- substr(ATRL$step[i], nchar(ATRL$step[i]), nchar(ATRL$step[i]) )
  }
  ATRQ <- mes.sel[which(substr(mes.sel$step, nchar(mes.sel$step)-1, nchar(mes.sel$step)-1 ) == Q.mark),]
  for (i in 1:length(ATRQ$step) ) {
    ATRQ$step.name[i] <- substr(ATRQ$step[i], nchar(ATRQ$step[i]), nchar(ATRQ$step[i]) )
  }
  
  # quick step
  for (i in ATRL$step.name) {
    iARN <- which(ARN$step.name == i)
    iATR <- which(ATR$step.name == i)
    
    iATRL <- which(ATRL$step.name == i)
    atrXL <- ATRL[iATRL, ]$X*aim.coef  - ARN[iARN, ]$X 
    atrYL <- ATRL[iATRL, ]$Y *aim.coef - ARN[iARN, ]$Y 
    atrZL <- ATRL[iATRL, ]$Z*aim.coef  - ARN[iARN, ]$Z 
    trL <- to.polar(atrXL, atrYL, atrZL)
    rateL <- (trL$F - ATR[iATR, ]$F) / (ATR[iATR, ]$F)
    FeL <- Fe*(1-rateL)
    SigFeL <- SigFe * (1-rateL)
    
    iATRQ <- which(ATRQ$step.name == i)
    atrXQ <- ATRQ[iATRQ, ]$X *aim.coef - ARN[iARN, ]$X 
    atrYQ <- ATRQ[iATRQ, ]$Y *aim.coef - ARN[iARN, ]$Y
    atrZQ <- ATRQ[iATRQ, ]$Z *aim.coef - ARN[iARN, ]$Z
    trQ <- to.polar(atrXQ, atrYQ, atrZQ)
    rateQ <- (trQ$F - ATR[iATR, ]$F) / (ATR[iATR, ]$F)
    
    if (verbose == TRUE) {
      Commentaire <- paste0('Speed Rate with slow step: ', format(rateL*100, digits = 4), ' %')
      Commentaire <- c( Commentaire, paste0('Derive speed Rate with quick step: ', format(rateQ*100, digits = 4), ' %') )
      Commentaire <- c( Commentaire, paste0('Fe Lent= ', format(FeL, digits = 3), ' ± ', format(SigFeL, digits = 3), ' µT') )
      
      print(Commentaire)      
                       
    }  
  }
  
  res$stat <- data.frame(Fe, SigFe, FeL, SigFeL, rateL, rateQ, sigmaCoe, JTRM, fCoe78, qCoe78, g, CrmMax, qPrevost85, sigmaPrevost85)
}
return(res)
}

```
```{r test calcul}
cov(tabX,tabY)
cov(tabY,tabX)
som =0
for (i in 1:length(tabX)) {
  som <- som + (tabX[i]-mean(tabX))*(tabY[i]-mean(tabY))
}

```

```{r}
plot(y= ARN$F, x=ATR$F, type='o', col = "blue", pch=16)
plot(ARN$F~ATR$F, type='b')
```

