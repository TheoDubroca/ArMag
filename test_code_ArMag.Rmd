---
title: "Test Code ArMag"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r pour creer un racourcie }
#shinyShortcut(shinyDirectory = "~/Documents/AM/R_Projects/ArMag/Visu_AM", OS = "unix",   gitIgnore = FALSE)
```

# Chargement des fonctions d'ArMag via GitHub
```{r echo = TRUE}

if (!require(devtools))
 {install.packages("devtools")}

devtools::install_github("chrono35/ArMag", force = TRUE)
library("ArMag") #, lib.loc="/Library/Frameworks/R.framework/Versions/3.5/Resources/library")
```

# Chargement des fonctions d'ArMag via source
Si besoin
```{r echo = TRUE}
# source('R/ArMag.R', echo=FALSE)

```

# Chargement fichier test avec fonction read.Pal




## Lecture fichier pal
```{r test read.Pal}
#file.AM <- "~/Documents/AM/GDRE1_INT.AMD"
# file.AM <- "/Volumes/Partage_Mesures_Archeomag/Mesures/22061_Glomel/22061A.AMD"
# file.AM <- "~/Documents/AM/22061_Glomel/22061A.AMD"
#file.AM <- "~/Documents/AM/53130_Laval/53130_Mesures/53130B1_2019.AMD"
#file.Pal <- "~/Documents/AM/Agnes&Maria/Portugal.txt"
file.Pal <- "examples/Portugal.txt"

mes <- NULL
mes <- read.Pal.mesures(file.Pal)
mes.info <- read.Pal.info (file.Pal)

desaim(mes)

# export en csv
#write.csv(mes, file = "~/Documents/AM/Agnes&Maria/Portugal.csv")
```

```{r}
# calcul de l'anisotropie moyenne
ani.moyen <- anisotropy.mean.eigen.tensor(mes, mes.info$number[1:20], step.value = 480, step.code = c("Z+", "Z-", "X+", "X-", "Y+", "Y-", "ZB"))

# calcul et stockage des anisotropies individuelles
ani.all.spe <- anisotropy.eigen.tensors.all(mes, mes.info$number[1:20], step.value = 480, step.code = c("Z+", "Z-", "X+", "X-", "Y+", "Y-", "ZB"))
ani.all.spe.mane <- cbind(mes.info$name[1:20], ani.all.spe)
```

```{r affichage anisotropie moyenne}
#png(paste(TeX.floder,"22061A_ANI.png", sep = "") , bg = "transparent", width = 1000) # Directement dans le dossier TeX
#par(mfrow = c(1, 2)) # pour exportation

par(mfrow = c(1, 2), cex.axis = 0.5)

lambert.ID.tensors(ani.all.spe)
lambert.ID.tensors(ani.moyen, pt.col = "red", new = FALSE)

flinn(ani.all.spe)
flinn(ani.moyen, pt.col = "red", new = FALSE)

# dev.off() # fin sauvegarde-exportation
```

# Chargement fichier test avec fonction read.AM

## Test execution
```{r test read.AM}
# file.AM <- "~/Documents/AM/GDRE1_INT.AMD"
# file.AM <- "/Volumes/Partage_Mesures_Archeomag/Mesures/22061_Glomel/22061A.AMD"
# file.AM <- "~/Documents/AM/22061_Glomel/22061A.AMD"
 file.AM <- "examples/14039C.AMP"
# file.AM <- "~/Documents/AM/Aire/40001A.AMD"

mes <- NULL
mes <- read.AM.mesures(file.AM)
mes.info <- read.AM.info (file.AM)
```


```{r test mcFadden}

select <- NULL
select$I <- mes$I[mes$step.value== 0]
select$D <- mes$I[mes$step.value== 0]

stat.mcFadden(select$I[1:8], select$D[1:8])


#lambert(mes, inc.lim = c(0,90))
```




# Codage symetrisation matrice



# Codage correction anisotropie
```{r}
# calcul les nouveaux paramètres d'un echantillon avec un tenseur donnée
#procedure Calcul_Aniso_Specimen(var R_Cal_echt:Res_Cal_xyz;Tens_ani:TENSEUR_ANISO );
mes.sel <- NULL
mes.sel1 <- extract.mesures.specimen.name("14P2", mes)

volume <- mes.info$vol[which(mes.info$name == trimws(mes.sel1$name[1]))]
TH <- mes.info$TH[which(mes.info$name == trimws(mes.sel1$name[1]))]
mes.sel1$X <- mes.sel1$X/volume * 1E6
mes.sel1$Y <- mes.sel1$Y/volume * 1E6
mes.sel1$Z <- mes.sel1$Z/volume * 1E6
ani1 <- anisotropy.matrix.symetric(mes.sel1, step.value = 550, TH = TH, volume = volume )

mes.sel2 <- extract.mesures.specimen.name("16P1", mes)
volume <- mes.info$vol[which(mes.info$name == trimws(mes.sel2$name[1]))]
TH <- mes.info$TH[which(mes.info$name == trimws(mes.sel2$name[1]))]
ani2 <- anisotropy.matrix.symetric(mes.sel2, step.value = 550, TH = TH, volume = volume )

mes.sel3 <- extract.mesures.specimen.name("24P1", mes)
volume <- mes.info$vol[which(mes.info$name == trimws(mes.sel3$name[1]))]
TH <- mes.info$TH[which(mes.info$name == trimws(mes.sel3$name[1]))]
ani3 <- anisotropy.matrix.symetric(mes.sel3, step.value = 550, TH = TH, volume = volume )


mes.sel4 <- extract.mesures.specimen.name("15P1", mes)
volume <- mes.info$vol[which(mes.info$name == trimws(mes.sel4$name[1]))]
TH <- mes.info$TH[which(mes.info$name == trimws(mes.sel4$name[1]))]
ani4 <- anisotropy.matrix.symetric(mes.sel4, step.value = 550, TH = TH, volume = volume )


mes.sel.ARN <- mes[mes$step.value == 0,]
mes.sel.ARN$X <- mes.sel.ARN$X /volume * 1E6
mes.sel.ARN$Y <- mes.sel.ARN$Y/volume * 1E6
mes.sel.ARN$Z <- mes.sel.ARN$Z/volume * 1E6

ani <- anisotropy.matrix.symetric(mes, step.value = 550)
ani.tens <- anisotropy.eigen.tensor(mes, step.value = 550 ) # eigen.tensor

# matrice moyenne
  ani.mean <- (ani2+ ani3 + ani4)/3
  eigen(ani.mean)
```



# test correction.anisotropie
```{r}
mes.sel <- NULL
mes.sel <- extract.mesures.specimen.name("24P1", mes)
volume <- mes.info$vol[which(mes.info$name == trimws(mes.sel$name[1]))]
TH <- mes.info$TH[which(mes.info$name == trimws(mes.sel$name[1]))]

mes.sel.ARN <- mes.sel[mes.sel$step.value == 0,]
mes.sel.ARN$X <- mes.sel.ARN$X /volume * 1E6
mes.sel.ARN$Y <- mes.sel.ARN$Y /volume * 1E6
mes.sel.ARN$Z <- mes.sel.ARN$Z /volume * 1E6

ani <- anisotropy.matrix.symetric(mes.sel, step.value = 550, TH = TH, volume = volume )

# normalisation des mesures en A/m
mes.sel$X <- mes.sel$X /volume * 1E6
mes.sel$Y <- mes.sel$Y /volume * 1E6
mes.sel$Z <- mes.sel$Z /volume * 1E6
correction.anisotropy(mes.sel, ani)
```


# Tracer


```{r selection}
mes.ech <- NULL
mes.ech <- extract.mesures.specimen.name("10P1", mes)
  mes.ech <- remove.step(mes.ech, step.value = 550, step.code = c("??"))
   mes.ech <- remove.step(mes.ech, step.value = 400, step.code = c("??"))
#mes.sel2 <- extract.mesures.specimen.number(2, mes2)
```
## Tracer de Zijderveld
```{r fonction plot.zjiderveld1}
par(pty="s") # force une figure carré
zijderveld1(mes.ech$X, mes.ech$Y, mes.ech$Z) #, pt.name = mes.ech$Etap)
par(mfrow = c(1,2), pty="m", cex.lab = 0.5, cex.axis = 0.6) # séparation en 2 colonnes et rétablie une figure taille maximale
# cex.axis défini la taille du texte des échelles
# cex.lab défini la taille du texte des étapes 
zijderveld1(mes.ech, legend.pos = "topright")
zijderveld2(mes.ech, pt.names = NULL)
```

Nous devons obtenir la même chose. Chacune des fonction utilisant des paramètres différents
```{r comparatif fonction plot}

lambert.XYZ.specimen(mes.ech)
lambert.ID.specimen(mes.ech)
```

# Calcul sur matrice

```{r test extract.aniso}
volume <- mes.info$vol[which(mes.info$name == trimws(mes.sel$name[1]))]
TH <- mes.info$TH[which(mes.info$name == trimws(mes.sel$name[1]))]

ani <- anisotropy.matrix.symetric(mes.sel, step.value = 550, TH = TH, volume = volume )
ani
```



```{r}
TH <- 60
mes.sel <- NULL
#mes.sel2 <- extract.mesures.specimen.name("19D", mes2)
mes.sel1 <- extract.mesures.specimen.number(1, mes)
mes.sel2 <- extract.mesures.specimen.number(2, mes)
mes.sel3 <- extract.mesures.specimen.number(3, mes)

ani1 <- anisotropy.eigen.tensor(mes.sel1, step.value = 550)
ani2 <- anisotropy.eigen.tensor(mes.sel2, step.value = 550 )
ani3 <- anisotropy.eigen.tensor(mes.sel3, step.value = 550 )

Data <- rbind(ani1, ani2, ani3)
lambert.ID.tensors(Data, point.col = c("blue", "red", "green"))
#

numbers <- c(7)
Data <- anisotropy.eigen.tensors.numbers(numbers, mes, mes.info, 400)
lambert.ID.tensors(Data, point.col = c("blue", "red", "green"))


numbers.selected <- NULL
  for (i in 1: length(mes$number) ) {
    if ( length(which( numbers.selected == mes$number[i] )) == 0 )
      numbers.selected <- c(numbers.selected, mes$number[i])
  }

```


```{r test plot.flin }
flinn(Data)#, points.col = c("red", "blue"), pt.names = c("titi", "toto"))

```

```{r codage desaimantation}
mes.seltt <- NULL
mes.seltt <- rbind(mes.sel1, mes.sel2)

 
```




```{r}
mes.sel2 <- extract.mesures.specimen.name("1T", mes)
mes.sel3 <- extract.mesures.specimen.name("17T", mes)
desaim(mes.sel2, etap.J0 = NULL)
desaim(mes, etap.J0 = 0, point.col = rainbow(length(mes.info$name)))
desaim(rbind(mes.sel2, mes.sel3), normalize = TRUE)

composante.partielle(mes.sel2$X, mes.sel2$Y, mes.sel2$Z)
```

```{r assemblé}

par(mfrow = c(2, 2), cex.lab = 0.7, cex.axis = .7, cex = 0.7, cex.main = 1, cex.sub = 0.1,
    mai = c(0.5, 0.5, 0.7, 0.3), oma = c(0, 1, 1, 1))#, pty ="s" )
zijderveld1.T1T2(mes.sel2)
zijderveld2.T1T2(mes.sel2)

# suppression des étapes d'anisotropie
mes.sel2 <- remove.step(mes.sel2) 
lambert(mes.sel2, inc.lim = c(0, 90))
desaim(mes.sel2, etap.J0 = NULL)
```





```{r genere AMD}
file.AM <- "~/Documents/AM/test.txt"
list.ech <- c("1T",   "17T",  "35T",  "47T",  "50T",  "59T",  "83T",  "87T",  "89T",  "94T",  "100T", "102T", "103T" )

```



# Calcul vecteur partiel
```{r code trace vecteur partiel}
# Procedure Calcul_vecteur_partiel(TabX,TabY,TabZ:array of Real; VAR MAD,SL,Xp,Yp,Zp:Real;en0:boolean;var Xm,Ym,Zm:Real);
# X, Y, Z, les coordonnées cartésiennes du vecteur partiel
en0 <- FALSE
T1 <- 200
T2 <- 400

withAni = FALSE
step.code <- c("Z+", "Z-", "X+", "X-", "Y+", "Y-", "ZB")
mes.sel2 <- extract.mesures.specimen.name("1T", mes)
ani.step.value <- NULL


res.list <- mes.sel2

if (withAni == FALSE) { # suppression des étape d anisotropie
 if (is.null(ani.step.value)) {
   for (i in 1:length(Data$Etap)) {
     if (substring(Data$Etap[i], 4) == step.code[3])
       ani.step.value <- Data$Etap.value[i]
   }
 }
  ani.step <- trimws(paste(ani.step.value, step.code, sep = ""))

 
 selec <- NULL
 for (i in 1:length(ani.step)) {
   selec <- c( selec, which(trimws(mes.sel2$Etap) == trimws(ani.step[i])) )
 }
 
 if (length(selec) > 0)
    res.list <- mes.sel2[-selec,]
}
         
Data <- res.list
# recherche étape en dessous de T1
iT1 <- 1
while(Data$Etap.value[iT1] < T1) {
  iT1 <- iT1 + 1
}

# recherche étape au dessus de T2
iT2 <- length(Data$Etap.value)
while(Data$Etap.value[iT2] > T2) {
  iT2 <- iT2 -1
}

# Calcul de la composante partielle

TabX <- Data$X[iT1:iT2]
TabY <- Data$Y[iT1:iT2]
TabZ <- Data$Z[iT1:iT2]

vp <- composante.partiel(TabX, TabY, TabZ, en0 = en0)
#ntab <- length(TabX)

 somx <- 0; somy <- 0; somz <- 0
 
 if (en0 == FALSE) {
   somx <- sum(TabX)
   somy <- sum(TabY)
   somz <- sum(TabZ)
 } 
    
  xm <- somx/ ntab
  ym <- somy/ ntab
  zm <- somz/ ntab

  
  
  # a, b : Valeurs indiquant le point d’interception sur l’axe des y et la pente de la droite -> y = a + bx
  # droite sur les déviations
  bd <- vp$X/vp$Y
  ad <- xm - bd*ym
   # droite sur les inclinaisons, +Z est négatif
  bi <- -vp$Z/vp$Y
  ai <- -zm - bi*ym
  
  Y.r <- range(Data$X)
  Z.r <- range(Data$Z)
  ylim <- c(min(Y.r[1], -Z.r[2]), max(Y.r[2], -Z.r[1]))
  
  if (ylim[1]>0)
    ylim[1]<-0
  
  if (ylim[2]<0)
    ylim[2]<-0

  
  zijderveld1(Data$X[1:iT1], Data$Y[1:iT1], Data$Z[1:iT1],  ylim = ylim) 
  zijderveld1(Data$X[iT1:iT2], Data$Y[iT1:iT2], Data$Z[iT1:iT2], pt.col = c("red", "red") , new = FALSE)
  zijderveld1(Data$X[iT2:length(Data$X)], Data$Y[iT2:length(Data$X)], Data$Z[iT2:length(Data$X)], new = FALSE)
  abline(ad, bd)
  abline(ai, bi)
```




```{r composante de tout le site}
sp.res <- NULL
for (sp in 1: length(mes.info$number)){
  sp.mes <- extract.mesures.specimen.number(mes.info$number[sp], mes)


  # correction d'anisotropie
  volume <- mes.info$vol[which(mes.info$name == trimws(sp.mes$name[1]))]
  TH <- mes.info$TH[which(mes.info$name == trimws(sp.mes$name[1]))]
  
  # normalisation des mesures en A/m
  sp.mes$X <- sp.mes$X /volume * 1E6
  sp.mes$Y <- sp.mes$Y /volume * 1E6
  sp.mes$Z <- sp.mes$Z /volume * 1E6
  
  # récupération de l'ARN
  #sp.mes.ARN <- sp.mes[sp.mes$step.value == 0,]
  

  # évaluation de l'anisotropie
  sp.ani <- anisotropy.matrix.symetric(sp.mes, step.value = 550, TH = TH, volume = volume )
 
  # suppression des étapes d'anisotropie
  sp.mes <- remove.step(sp.mes) #, step.value = "0", step.code = "N") 
    
  # correction de l'anisotropie  
  sp.cor <- correction.anisotropy(sp.mes, sp.ani)
  
  # determination de la composante
  sp.cp <- composante.partielle(sp.cor$X, sp.cor$Y, sp.cor$Z)
  
  # repliement
  sp.cp <- repliement.auto(sp.cp$I, sp.cp$D, name = sp.mes$name)
  sp.res <- rbind.data.frame(sp.res, cbind(name =mes.info$name[sp], sp.cp) )
}


stat.mcFadden(sp.res$I, sp.res$D)


lambert(sp.res, inc.lim = c(0,90))
```

```{r}

Data <- spe.83
T1 = 100
T2 = 350
show.step = TRUE
 withAni = FALSE; ani.step.value = NULL;
                             step.code = c("Z+", "Z-", "X+", "X-", "Y+", "Y-", "ZB");
                             legend.pos = NULL; legend.txt = c("(Y, X)", "(Y, Z)");
                             en0 = FALSE


  if (is.null(T1))
    T1 <- Data$step.value[1]
  if (is.null(T2))
    T2 <- Data$step.value[length(Data$step.value)]


  res.list <- Data

  if (withAni == FALSE) { # suppression des étape d anisotropie
    Data <- remove.step(Data, ani.step.value = ani.step.value, step.code = step.code)
  }
  # recherche étape en dessous de T1
  iT1 <- 1
  while(Data$step.value[iT1] < T1) {
    iT1 <- iT1 + 1
  }

  # recherche étape au dessus de T2
  iT2 <- length(Data$step.value)
  while(Data$step.value[iT2] > T2) {
    iT2 <- iT2 -1
  }

  # Calcul de la composante partielle

  TabX <- Data$X[iT1:iT2]
  TabY <- Data$Y[iT1:iT2]
  TabZ <- Data$Z[iT1:iT2]

  vp <- composante.partielle(TabX, TabY, TabZ, en0 = en0)
  ntab <- length(TabX)

  somx <- 0; somy <- 0; somz <- 0

  if (en0 == FALSE) {
    somx <- sum(TabX)
    somy <- sum(TabY)
    somz <- sum(TabZ)
  }

  xm <- somx/ ntab
  ym <- somy/ ntab
  zm <- somz/ ntab

  # a, b : Valeurs indiquant le point d’interception sur l’axe des y et la pente de la droite -> y = a + bx
  # droite sur les déviations axe (Y, X)
  bd <- vp$X/vp$Y
  ad <- xm - bd*ym
  # droite sur les inclinaisons axe (Y, Z), +Z est négatif
  bi <- -vp$Z/vp$Y
  ai <- -zm - bi*ym

  Y.r <- range(Data$X)
  Z.r <- range(Data$Z)
  ylim <- c(min(Y.r[1], -Z.r[2]), max(Y.r[2], -Z.r[1]))

  if (ylim[1]>0)
    ylim[1]<-0

  if (ylim[2]<0)
    ylim[2]<-0

  if (show.step == TRUE) {
    pt.names <- Data$step
  } else {
     pt.names <- rep("", length(Data$X) )
  }
   

  zijderveld1(Data$X[1:iT1], Data$Y[1:iT1], Data$Z[1:iT1],  ylim = ylim, pt.names = pt.names[1:iT1], legend.pos = legend.pos, legend.txt = legend.txt )
  if (iT2 != length(Data$X))
    zijderveld1(Data$X[iT2:length(Data$X)], Data$Y[iT2:length(Data$X)], Data$Z[iT2:length(Data$X)], pt.names = pt.names[iT2:length(Data$X)], new = FALSE)

  zijderveld1(Data$X[iT1:iT2], Data$Y[iT1:iT2], Data$Z[iT1:iT2], pt.col = c("red", "red") , pt.names = pt.names[iT1:iT2], new = FALSE)

  abline(ad, bd)
  abline(ai, bi)

  Data$step

```

# Calcul azimut du soleil
```{r}
JulianDay <- function(day, month, year, UT=12)
  # valid from 1900/3/1 to 2100/2/28 # http://jgiesen.de/elevazmoon/basics/meeus.htm
  # equivalent à la fonction dans R : julian(Sys.Date(), -2440588)
  # ISOdate(year, month, day, hour = 12, min = 0, sec = 0, tz = "GMT")
{
  #  if (month<=2) {
   #   month=month+12
   #   year=year-1
   #   }
    #return ( trunc(365.25*year) + trunc(30.6001*(month+1)) - 15 + 1720996.5 + day + UT/24.0 )
  return ( 367*year-7*trunc( (year+trunc((month+9)/12 ) )/4)+275*trunc(month/9)+day+1721014 ) # https://cral-perso.univ-lyon1.fr/labo/fc/cdroms/docu_astro/jour_julien/jour_julien.pdf
} 
```




```{r}
#sun.azimuth <- function(Day, Month, Year, Hour, Minute, Seconde=0, longdeg, longmin=0, longsec=0, latdeg, latmin=0, latsec=0, deviation = 0, tz = "UTC")
#{
#D:jour M:Month  Y:Year HH:Hour  NN:Minute KK:seconde
  #  DD:=longdeg;  FF:=longmin;  SS:=longsec;  ZZ:=latdeg;  YY:=latmin;  XX:=latsec;
#   les valeurs des degres minutes et secondes peuvent etre negatives dans la procedure}
# Pour la France tz = "Europe/Paris", calcul alors automatiquement le décalage horaire
  Day=13 ; Month=07; Year=1999; Hour=13; Minute=3; Seconde=0; 
longdeg=-1; longmin=40; longsec=21; 
latdeg=43; latmin=14; latsec=47; deviation = 0;
tz = "UTC"
  
cmp <- function(expres ) {
  if (expres == TRUE) {
    return(-1)
  } else {
    return(0)
  }
}

absTrunc <- function(x) {
  return(as.numeric(trunc(x)))
}

RAD <- pi/180
#LongNeg <- (longdeg<0)
#LatNeg <- (latded<0)
# modification des longitudes et latitudes 
#if(longdeg<0) {
#  longdeg =-abs(longdeg)
#          longmin = -longmin
##          longsec = -longsec
#}
    
 # LON = longdeg +(longmin /60)+(longsec/3600)
  LON <- DMS.to.DD(longdeg, longmin, longsec)

#  if( latdeg<0) {
#    latdeg=-Abs(latdeg)
#       latmin=-latmin
#       latsec=-latsec
#  } 
 # LAT = latdeg+ latmin/60+ latsec/3600;
  LAT <- DMS.to.DD(latdeg, latmin, latsec)

 # if ( (Month=1) | (Month=2)){
#    Year = Year-1
 #   Month = Month+12
 # } 
 # A = absTrunc(Year/100)
 # B = 2 - A + absTrunc(A/4)
 # J = absTrunc(365.25*Year) + absTrunc(30.6001*(Month+1)) + Day + 1720995 + B -0.5

  H = Hour + Minute/60 +Seconde/3600
 # J1 = J + H/24
 
  #J <- trunc(365.25*Year) + trunc(30.6001*(Month+1)) - 15 + 1720996.5 + Day 
  J1 <- calcul_jour_julien(Day, Month, Year, heure =  Hour, Minute, Seconde) 
  
 # J1 <- julian(as.Date(ISOdatetime(year = Year, month = Month, day = Day, hour = Hour, min = Minute, sec = Seconde, tz = tz)), -2440588)
  
  Ta = (J1-2.41502E+06)/36525
  EX = 0.01675104-0.0000418*Ta
  EP = 23.45229444-0.013012*Ta
  L1 = 279.696678+36000.76892*Ta
  L = (L1/360- abs(L1/360))*360
  M1 = 358.4758445+35999.04975*Ta
  MPrim = (M1/360- abs(M1/360))*360
  MR = MPrim*RAD
  VR = MR + 2*EX*sin(MR) + (5*EX*EX*sin(2*MR)/4) + (EX*EX*EX)*( (13*sin(3*MR)/12)- sin(MR)/4)
  V = VR*180/pi
  OM = 259.18-1934.14*Ta
  L2 = L+V-MPrim - 0.00569- 0.00479*sin(OM*RAD)
  K = cos(EP*RAD)*cos(L2*RAD)/cos(L2*RAD)
  ALF = atan(K)
  if ((Month>5) & (Month<13)) {
    ALF = ALF + (cmp(K<0)*cmp(Month<10)+cmp(K>0)*cmp(Month>8))*pi
  }
  Q = sin(EP*RAD)*sin(L2*RAD)
  DELT = atan(Q/sqrt(1-Q*Q))
  DEC = DELT*180/pi
  ALFA = ALF*180/pi
  T1 = (J-2.41502E+06)/36525;
  # TSL = Temps sideral local en heure décimale }
  PT = 1.05*sin(OM*RAD)/3600;
  PR = (0.08*sin((199-72002*T1)*RAD))/3600
  TSL = 6.64079 +2400.051278*T1+ (0.095*(T1^2)/3600) - PT-PR+ LON/15+ H*1.0027379
  TSL = TSL-24*absTrunc(TSL/24)
  
  AH = TSL-ALFA/15
  R = sin(AH*15*RAD)/(sin(LAT*RAD)*cos(AH*15*RAD)-cos(LAT*RAD)*atan(DEC*RAD))
  AZ = atan(R)*180/pi
  AZ = AZ+180
  if(AH<0) {
    AH = AH+24
  } 
  AH = AH -24*absTrunc(AH/24)
  
  # AZ : azimut du soleil 
  if ((AH>12) & (AZ>180)) 
    AZ= AZ+180
  if ((AH<12) & (AZ<180))
    AZ = AZ+180  

  if (deviation>=0) {
    deviation = deviation + (AZ-360)*RAD
  } else deviation = deviation + AZ*RAD

  deviation <- deviation/RAD
#return(deviation)
#}
```


```{r}
# Le jour julien 0 commence le 24 novembre -4713 (4712 BC) à 12h
#' Le nombre de jour julien pour les calculs astronomiques
#' @seealso \code{\link{https://codes-sources.commentcamarche.net/source/31774-calcul-de-la-position-du-soleil-declinaison-angle-horaire-altitude-et-azimut-altaz-solaire}}
#' @export
jour.julien <- function( jour,   mois,   annee,   heure,   minute,   seconde)
{
        day <- jour + heure/24 + minute/1440 + seconde/86400
        year <- annee
        month <- mois

        if (month == 1 || month == 2)
        {
                year <- year-1
                month <- month+12
        }

        a <- trunc(year/100)
        b <- 2 - a + trunc(a/4)

        jour_julien <- trunc(365.25*(year+4716)) + trunc(30.6001*(month+1)) + day + b - 1524.5
        
        return (as.numeric(jour_julien))
}
```

```{r juju}
juju <- function( jour,   mois,   annee)
{
            jour_julien <- (1461 * (annee + 4800 + (mois - 14)/12))/4 +(367 * (mois - 2 - 12 * ((mois - 14)/12)))/12- (3 * ((annee + 4900 + (mois - 14)/12)/100))/4 + jour - 32075.0
        return (as.numeric(jour_julien) )
}
```


```{r}
# https://codes-sources.commentcamarche.net/source/31774-calcul-de-la-position-du-soleil-declinaison-angle-horaire-altitude-et-azimut-altaz-solaire

# Pour controler
# https://www.sunearthtools.com/dp/tools/pos_sun.php?lang=fr
# https://fr.planetcalc.com/320/

jour2= 28 ; mois2= 04; annee2= 1994; heure2= 12; minute2= 51; seconde2= 10
longitude= 20; longmin= 20; longsec= 46    # Est est positif, et Ouest est négatif
latitude= 50; latmin= 41; latsec= 53; deviation = 0
tz = "UTC"
sun.azimuth(jour2, mois2, annee2, heure2, minute2, seconde2, longitude, longmin, longsec, latitude, latmin, latsec)
360-sun.azimuth(jour2, mois2, annee2, heure2, minute2, seconde2, longitude, longmin, longsec, latitude, latmin, latsec)
```


```{r sun.azimuth}
#' Calcul l'azimuth du soleil en un lieu à une date donnée à une heure "UTC"
#' @seealso \code{\link{https://codes-sources.commentcamarche.net/source/31774-calcul-de-la-position-du-soleil-declinaison-angle-horaire-altitude-et-azimut-altaz-solaire}}
#' @seealso \code{\link{https://fr.planetcalc.com/320/}}
#' @export
sun.azimuth <- function(Day, Month, Year, Hour, Minute, Seconde=0, longdeg, longmin=0, longsec=0, latdeg, latmin=0, latsec=0) {
# -----------------------------heure d'hiver ou d'été---------------------------
correction_heure <- 0

jj <- jour.julien(jour2, mois2, annee2, heure2, minute2, seconde2) - correction_heure/24.0 - 2451545.0


#-------------calculs ascension droite et délinaison-------------
g <- 357.529 + 0.98560028*jj
q <- 280.459 + 0.98564736*jj
l <- q + 1.915 * sin(g*pi/180.0) + 0.020*sin(2*g*pi/180.0) # Ellipticité
e <- 23.439 - 0.00000036*jj

ascension_droite <- atan(cos(e*pi/180.0)*sin(l*pi/180.0)/cos(l*pi/180.0))*(180.0/pi)/15.0
if (cos(l*pi/180.0) < 0)
{
        ascension_droite <- 12.0 + ascension_droite
}
if (cos(l*pi/180.0)>0 && sin(l*pi/180.0) < 0)
{
        ascension_droite <- ascension_droite + 24.0
}
declinaison <- asin(sin(e*pi/180.0)*sin(l*pi/180.0))*180.0/pi


nb_siecle <- jj/36525.0
heure_siderale1 <- (24110.54841+(8640184.812866*nb_siecle)+(0.093104*(nb_siecle*nb_siecle))-(0.0000062*(nb_siecle*nb_siecle*nb_siecle)))/3600.0
heure_siderale2 <- ((heure_siderale1/24.0) - trunc(heure_siderale1/24.0)) * 24.0

angleH <- 360.0*heure_siderale2/23.9344
angleT <- (heure2-correction_heure-12.0+minute2/60.0+seconde2/3600.0)*360.0/23.9344 # jour sidéraux = 23h56min 4,0989s -> 23,93447h -> 0,9972696 jour solaire
angle <- angleT + angleH

angle_horaire <- angle - ascension_droite*15.0 + longitude

#-------------calculs altitude et azimut-------------------------


altitude <- asin( sin(declinaison*pi/180.0)*sin(latitude*pi/180.0) - cos(declinaison*pi/180.0)*cos(latitude*pi/180.0)*cos(angle_horaire*pi/180.0) )*180.0/pi

azimut <- acos( (sin(declinaison*pi/180.0)-sin(latitude*pi/180.0)*sin(altitude*pi/180.0)) / (cos(latitude*pi/180.0)*cos(altitude*pi/180.0)) )*180.0/pi
sinazimut <- (cos(declinaison*pi/180.0)*sin(angle_horaire*pi/180.0)) / cos(altitude*pi/180.0)
if (sinazimut<0)
{
        azimut <-360-azimut;
}

return(as.numeric(azimut))
}
```



```{r test sun.azimuth}

sun.azimuth (10, 11, 2019, 11, 19, Seconde=0, 48, longmin=0, longsec=0, 45, latmin=0, latsec=0, deviation = 0)

```
# Relocation
## GAD
controlé OK
```{r GAD}
#' Geocentric Axial Dipole
#' Correction Dipôle Axiale Centré
#' @return I.reloc en degré
#' @example relocate.GAD(65, 47.12)
relocate.GAD <- function( I.site, lat.site,  lat.reloc = "Paris")
{
  if (lat.reloc == "Paris") {
    lat.reloc <- 48.85
  }
  if (lat.reloc == "Madrid") {
    lat.reloc <- 40.4
  }
  if (lat.reloc == "Meriden") {
     lat.reloc <- 52.43
  }
  if (lat.reloc == "Athenes") {
    lat.reloc <- 37.96
  }
  
  I.reloc <- I.site + 0.5 * (3 * cos(I.site * pi /180)^2 + 1) * (lat.reloc - lat.site)
     
  return(data.frame(I.reloc = I.reloc) )
}
```


## VDM
Controlé OK
```{r VDM}
#' Virtual Dipôle Moment
#' @example relocate.VDM(55, 65,5, 47.12, 2.175,"Paris")
relocate.VDM <- function( F.site, I.site, D.site, lat.site, lon.site, lat.reloc = "Paris", lon.reloc = 0)
{
  if (lat.reloc == "Paris") {
    lon.reloc <- 2.3
    lat.reloc <- 48.85
  }
  if (lat.reloc == "Madrid") {
    lon.reloc <- -3.68
    lat.reloc <- 40.4
  }
  if (lat.reloc == "Meriden") {
    lon.reloc <- -1.62
    lat.reloc <- 52.43
  }
  if (lat.reloc == "Athenes") {
    lon.reloc <- 23.72
    lat.reloc <- 37.96
  }
  
  rad <- pi /180
  LAR <- lat.reloc * rad
  LGR <- lon.reloc * rad
  LA <- lat.site * rad
  LG <- lon.site * rad

  # Calcul de la distance p du pôle 
  pol <- (pi / 2) - atan(tan(I.site * rad) / 2)
  lap <- asin(sin(LA) * cos(pol) + cos(LA) * sin(pol) * cos(D.site * rad))
  beta <- asin(sin(pol) * sin(D.site * rad) / cos(lap))
  if (cos(pol) >= (sin(LA) * sin(lap)))
  {
    lgp <- LG + beta
  }
  else 
  {
      lgp <- LG + pi - beta
  }

  # Calcul de Iij et Dij corrigés
  pol <- acos(sin(LAR) * sin(lap) + cos(LAR) * cos(lap) * cos(lgp - LGR))
  I.reloc <-  as.numeric(atan(2 * tan((pi / 2) - pol)) )
  F.reloc <-  as.numeric( F.site * sqrt((3 * cos(I.site * rad)^2 + 1) / (3 *  cos(I.reloc)^2 + 1)) )

  return(data.frame(I.reloc = I.reloc /rad , F.reloc = F.reloc, lat.pole = lap / rad , lon.pole = lgp / rad))
}
```

## VADM
Controlé OK
```{r VADM}
#' Virtual Axial Dipole Moment VADM
#' @example relocate.VADM(55, 47.12) # resitué par defaul à Paris
#' @example relocate.VADM(55, 47.12, "Paris")
#' @example relocate.VADM(55, 47.12, lat.reloc = 48.85")
relocate.VADM <- function( F.site,  lat.site,  lat.reloc = "Paris")
{
  if (lat.reloc == "Paris") {
    lat.reloc <- 48.85
  }
  if (lat.reloc == "Madrid") {
    lat.reloc <- 40.4
  }
  if (lat.reloc == "Meriden") {
     lat.reloc <- 52.43
  }
  if (lat.reloc == "Athenes") {
    lat.reloc <- 37.96
  }
  F.reloc <-  as.numeric(F.site * sqrt((3 * sin(lat.reloc * pi /180)^2 + 1) / (3 * sin(lat.site * pi /180)^2 + 1)) )
  return(data.frame(F.reloc = F.reloc))
}
```

## VGP
Controlé OK
```{r VGP}
#' Correction Virtual Geomagnetic Pole
#' VGP exacte: Westphal, p.117 et Merill McElhinny, p.80
#' Paris lat:48.85 lon:2.3
#' Madrid lat:40.4 lon:-3.68
#' Meriden lat:52.43 lon:-1.62
#' Athenes lat:37.96 lon:23.72
#' 
relocate.VGP <- function(I.site, D.site, lat.site, lon.site,  lat.reloc = "Paris", lon.reloc = 0)
{
  rad <- as.numeric(pi /180)
  degre <- as.numeric(180 /pi)
  
  if (lat.reloc == "Paris") {
    lon.reloc <- 2.3
    lat.reloc <- 48.85
  }
  if (lat.reloc == "Madrid") {
    lon.reloc <- -3.68
    lat.reloc <- 40.4
  }
  if (lat.reloc == "Meriden") {
    lon.reloc <- -1.62
    lat.reloc <- 52.43
  }
  if (lat.reloc == "Athenes") {
    lon.reloc <- 23.72
    lat.reloc <- 37.96
  }
  LAR <- lat.reloc * rad
  LGR <- lon.reloc * rad
  LA <- lat.site * rad
  LG <- lon.site * rad
  # Calcul de la distance p du pôle 
  pol <- (pi / 2) - atan(tan(I.site * rad) / 2)
  lap <- asin(sin(LA) * cos(pol) + cos(LA) * sin(pol) * cos(D.site * rad))
  beta <- asin(sin(pol) * sin(D.site * rad) / cos(lap))
  if (cos(pol) >= (sin(LA) * sin(lap))) 
  {
    lgp <- LG + beta
  }
  else 
  {
    lgp <- LG + pi - beta
  }
  # Calcul de Iij et Dij corrigés
  pol <- acos(sin(LAR) * sin(lap) + cos(LAR) * cos(lap) * cos(lgp - LGR))
  I.reloc <- atan(2 * tan((pi / 2) - pol)) * degre 
  D.reloc <- asin(sin(lgp - LGR) * cos(lap) / sin(pol)) * degre 

  return(data.frame(I.reloc = as.numeric(I.reloc),  D.reloc = as.numeric(D.reloc), lat.pole = as.numeric(lap*degre) , lon.pole = as.numeric(lgp*degre) ) )
}
```

# Vieux fichier


```{r read.AM.oldType.mesures}
file.AM <- "~/Documents/AM/old-type.AMD"
#file.AM <- "~/Documents/AM/66006_Ansignan/66006A.AMD"
test.file <- read.AM.oldType.info(file.AM, encoding = "macroman")

```


