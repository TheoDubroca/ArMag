---
title: "Test Code ArMag"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r pour crer un racourcie }
#shinyShortcut(shinyDirectory = "~/Documents/AM/R_Projects/ArMag/Visu_AM", OS = "unix",   gitIgnore = FALSE)
```

# Chargement des fonctions d'ArMag via GitHub
```{r echo = TRUE}

if (!require(devtools))
 {install.packages("devtools")}

devtools::install_github("chrono35/ArMag", force = TRUE)
library("ArMag", lib.loc="/Library/Frameworks/R.framework/Versions/3.5/Resources/library")
```

# Chargement des fonctions d'ArMag via source
```{r echo = TRUE}
 source('~/Documents/AM/R_Projects/ArMag/R/ArMag.R', echo=FALSE)

```

# Chargement fichier test avec fonction read.AM




## Test execution
```{r test read.AM}
#file.AM <- "~/Documents/AM/GDRE1_INT.AMD"
# file.AM <- "/Volumes/Partage_Mesures_Archeomag/Mesures/22061_Glomel/22061A.AMD"
 file.AM <- "~/Documents/AM/22061_Glomel/22061A.AMD"
#file.AM <- "~/Documents/AM/53130_Laval/53130_Mesures/53130B1_2019.AMD"
mes <- NULL
mes <- read.AM.mesures(file.AM)
mes.info <- read.AM.info (file.AM)
```

```{r}
Data <- mes
main = NULL

F = NULL;  point.col = c("blue3", "red"); pch = 21; type= "b";
                             xlab = "°C"; ylab = ""; main = NULL;
                             names = NA; normalize = TRUE; new = TRUE

 tmp.frame <- NULL
  if (is.null(main))
    main <- " F vs Etap.value"

  if(is.data.frame(Data)) {
    tmp.frame$name <- Data$name[!is.na(Data$Etap.value)]
    tmp.frame$Etap.value <- Data$Etap.value[!is.na(Data$Etap.value)]
    tmp.frame$F <- Data$F[!is.na(Data$Etap.value)]


  } else {
    # Création du frame interne
    if (is.na(names))
      tmp.frame$name <- as.character(c(1: length(Data)))
    else
      tmp.frame$name <- names

    tmp.frame$Etap.value <- Data
    tmp.frame$F <- F
  }

  # comptage et séparation des données
  current <- tmp.frame$name[1]
  list.name <- current

  for (i in 1: length(tmp.frame$name)) {
    if ( tmp.frame$name[i] != current) {
      current <- tmp.frame$name[i]
      list.name<- c(list.name, current)
    }
  }

  xlim <- range(tmp.frame$Etap.value)

  YMax <-max(tmp.frame$F)

   if (normalize) {
    ylim <- c(0, 100)

  } else {
    ylim <- c(0, max(tmp.frame$F))
  }

  if (length(point.col) < length(tmp.frame$Etap.value) )
      point.col <- rep(point.col, length(tmp.frame$Etap.value) )

  for (i in 1 : length(list.name)) {
   if (normalize == TRUE)
      coefY <- 100 / max(tmp.frame$F[tmp.frame$name == list.name[i]])
    else 
      coefY <- 1
    Xi <- tmp.frame$Etap.value[tmp.frame$name == list.name[i]]
    Yi <- tmp.frame$F[tmp.frame$name == list.name[i]]  * coefY 

    if (i == 1)
      plot(x=Xi, y=Yi, xlab = xlab, ylab = ylab, ylim = ylim, xlim = xlim, type = type, col= adjustcolor( point.col[i], alpha.f = 0.7), bg = point.col[i], pch = pch,
           yaxt="n", bty ="n", main = main, new = new)
    else
      lines(x=Xi, y=Yi, type = type, col=adjustcolor( point.col[i], alpha.f = 0.7), bg = point.col[i], pch = pch, yaxt="n", bty ="n")

  }

  axis(2, pos = 0, cex.axis = 0.8, col = "darkgray") # Ordonnées

  mtext( format(YMax, digits = 3), side = 3, col = "gray5", adj = 0, cex.axis = 0.8)


```

# codage symetrisation matrice
```{r}
anisotropie.matrix.symetric <- function(mesures, etape.value, etape.sigle = c("Z+", "Z-", "X+", "X-", "Y+", "Y-", "ZB"), volume = 1, TH = 1,...)
{

  ani.etape <- trimws(paste(as.character(etape.value), etape.sigle, sep = "") )

  selec <- NULL
  for (i in 1:length(ani.etape)) {
    selec <- c( selec, which(trimws(mesures$Etap) == trimws(ani.etape[i])) )
  }
  res.list <- NULL
  res.list <- mesures[selec,]
  res.list <- res.list

  mat.plus <- matrix( c( res.list$X[3], res.list$X[5], res.list$X[1],
                         res.list$Y[3], res.list$Y[5], res.list$Y[1],
                         res.list$Z[3], res.list$Z[5], res.list$Z[1]) , 3, 3)


  mat.moins <- matrix( c( res.list$X[4], res.list$X[6], res.list$X[2],
                          res.list$Y[4], res.list$Y[6], res.list$Y[2],
                          res.list$Z[4], res.list$Z[6], res.list$Z[2]) , 3, 3)
  mat.reel <- (mat.plus - mat.moins)/2 / (volume * 1E-6)# / coef.norm

  # Symetrisation
  coef.norm <- TH* 10/ (4*pi)
  kxx <- mat.reel[1,1] / coef.norm
  kyy <- mat.reel[2,2] / coef.norm
  kzz <- mat.reel[3,3] / coef.norm
  kxy <- (mat.reel[1,2] + mat.reel[2,1]) / 2 / coef.norm
  kxz <- (mat.reel[1,3] + mat.reel[3,1]) / 2 / coef.norm
  kyz <- (mat.reel[2,3] + mat.reel[3,2]) / 2 / coef.norm

  # normalisation
  suscept <- (kxx + kyy + kzz)/3
  mat.sym.norm <- matrix( c( kxx / suscept, kxy / suscept, kxz / suscept,
                             kxy / suscept, kyy / suscept, kyz / suscept,
                             kxz / suscept, kyz / suscept, kzz / suscept) , 3, 3)

  return(mat.sym.norm)

}
```


# Codage correction anisotropie
```{r}
# calcul les nouveaux paramètres d'un echantillon avec un tenseur donnée
#procedure Calcul_Aniso_Specimen(var R_Cal_echt:Res_Cal_xyz;Tens_ani:TENSEUR_ANISO );
mes.sel <- NULL
mes.sel1 <- extract.mesures.specimen.name("14D", mes)

volume <- mes.info$vol[which(mes.info$name == trimws(mes.sel1$name[1]))]
TH <- mes.info$TH[which(mes.info$name == trimws(mes.sel1$name[1]))]
mes.sel1$X <- mes.sel1$X/volume * 1E6
mes.sel1$Y <- mes.sel1$Y/volume * 1E6
mes.sel1$Z <- mes.sel1$Z/volume * 1E6
ani1 <- anisotropie.matrix.symetric(mes.sel1, etape.value = 400, TH = TH, volume = volume )

mes.sel2 <- extract.mesures.specimen.name("19D", mes)
volume <- mes.info$vol[which(mes.info$name == trimws(mes.sel2$name[1]))]
TH <- mes.info$TH[which(mes.info$name == trimws(mes.sel2$name[1]))]
ani2 <- anisotropie.matrix.symetric(mes.sel2, etape.value = 400, TH = TH, volume = volume )

mes.sel3 <- extract.mesures.specimen.name("49D", mes)
volume <- mes.info$vol[which(mes.info$name == trimws(mes.sel3$name[1]))]
TH <- mes.info$TH[which(mes.info$name == trimws(mes.sel3$name[1]))]
ani3 <- anisotropie.matrix.symetric(mes.sel3, etape.value = 400, TH = TH, volume = volume )


mes.sel4 <- extract.mesures.specimen.name("57D", mes)
volume <- mes.info$vol[which(mes.info$name == trimws(mes.sel4$name[1]))]
TH <- mes.info$TH[which(mes.info$name == trimws(mes.sel3$name[1]))]
ani4 <- anisotropie.matrix.symetric(mes.sel4, etape.value = 400, TH = TH, volume = volume )


mes.sel.ARN <- mes.sel[mes.sel$Etap.value == 0,]
mes.sel.ARN$X <- mes.sel.ARN$X /volume * 1E6
mes.sel.ARN$Y <- mes.sel.ARN$Y/volume * 1E6
mes.sel.ARN$Z <- mes.sel.ARN$Z/volume * 1E6

ani <- anisotropie.matrix.symetric(mes.sel, etape.value = 400, TH = TH, volume = volume )
ani.tens <- anisotropie.tensor(mes.sel, etape.value = 400, TH = TH, volume = volume ) # eigen.tensor

# matrice moyenne
  ani.mean <- (ani2+ ani3 + ani4)/3
  eigen(ani.mean)
```

```{r}
correction.anisotropie <- function(mesures.frame, ani.matrix)
{

#mesures.frame <- mes.sel
#ani.matrix <- ani
  if (!is.data.frame(mesures.frame))
    warning("mesures n'est pas une data.frame")
  if (!is.matrix(ani.matrix))
    warning("ani.matrix n'est pas une matrice")
  
  nbMesures <- length(mesures.frame[,1])
  
  # inversion de la matrice
  ani.inv <- solve(ani.matrix)

  r_cal_echt <- NULL
  # Calcul pour une mesure
  correct <- function(mesure, aniso.inv) {
    # Calcul de la correction
    re.cal.ani <- aniso.inv %*% c( mesure$X, mesure$Y, mesure$Z)
    # recopie des variables
    re.cal <- mesure
    re.cal$X <- re.cal.ani[1]
    re.cal$Y <- re.cal.ani[2]
    re.cal$Z <- re.cal.ani[3]
    re.cal.ID <- polaire(re.cal$X, re.cal$Y, re.cal$Z)
    re.cal$I <- re.cal.ID$I
    re.cal$D <- re.cal.ID$D
    re.cal$F <- re.cal.ID$F
    
    return(re.cal)
  }
  
  resT <- NULL
  for (i in 1 : nbMesures)
    resT <- rbind(resT, correct(mesures.frame[i,], ani.inv))
 
  return(resT)
}  
```

# test correction.anisotropie
```{r}
mes.sel <- NULL
mes.sel <- extract.mesures.specimen.name("49D", mes)
volume <- mes.info$vol[which(mes.info$name == trimws(mes.sel$name[1]))]
TH <- mes.info$TH[which(mes.info$name == trimws(mes.sel$name[1]))]

mes.sel.ARN <- mes.sel[mes.sel$Etap.value == 0,]
mes.sel.ARN$X <- mes.sel.ARN$X /volume * 1E6
mes.sel.ARN$Y <- mes.sel.ARN$Y /volume * 1E6
mes.sel.ARN$Z <- mes.sel.ARN$Z /volume * 1E6

ani <- anisotropie.matrix.symetric(mes.sel, etape.value = 400, TH = TH, volume = volume )

# normalisation des mesures en A/m
mes.sel$X <- mes.sel$X /volume * 1E6
mes.sel$Y <- mes.sel$Y /volume * 1E6
mes.sel$Z <- mes.sel$Z /volume * 1E6
correction.anisotropie(mes.sel, ani)
```


```{r test extract.mesures.specimen.name}
mes.sel <- NULL
mes.sel <- extract.mesures.specimen.name("44188A_17B1", mes)
```


# Tracer de cercle

```{r Test read.AM.info }
file.AM2 <- "~/Documents/AM/53130B1_2019.AMD"
mes2 <- read.AM.mesures (file.AM2)
mes2.info <- NULL
mes2.info <- read.AM.info (file.AM2)
```

```{r selection}
mes.sel2 <- NULL
mes.sel2 <- extract.mesures.specimen.name("19D", mes2)
#mes.sel2 <- extract.mesures.specimen.number(2, mes2)
```

```{r fonction plot.zjiderveld1}
par(pty="s") # force une figure carré
plot.zjiderveld1(mes.sel2$X, mes.sel2$Y, mes.sel2$Z, pt.name = mes.sel2$Etap)
par(mfrow = c(1,2), pty="m") # séparation en 2 colonnes et rétablie une figure taille maximale
plot.zjiderveld1(mes.sel2, legend.pos = "topright")
plot.zjiderveld2(mes.sel2, pt.names = NULL)
```




```{r comparatif fonction plot}
plot.lambert.XYZ.specimen(mes.sel2)
plot.lambert.ID.specimen(mes.sel2)
```

# calcul sur matrice

```{r test extract.aniso}
volume <- mes2.info$vol[which(mes2.info$name == trimws(mes.sel2$name[1]))]
TH <- mes2.info$TH[which(mes2.info$name == trimws(mes.sel2$name[1]))]

ani <- anisotropie.matrix(mes.sel2, etape.value = 400, TH = TH, volume = volume )
ani
```

```{r code plot.ani}
mes.sel1 <- extract.mesures.specimen.number(1, mes2)
mes.sel2 <- extract.mesures.specimen.number(2, mes2)
mes.sel3 <- extract.mesures.specimen.number(3, mes2)

ani1 <- anisotropie.tensor(mes.sel1, etape.value = 400, TH = TH, volume = mes2.info$vol[which(mes2.info$name == trimws(mes.sel1$name[1]))] )
ani2 <- anisotropie.tensor(mes.sel2, etape.value = 400, TH = TH, volume = mes2.info$vol[which(mes2.info$name == trimws(mes.sel2$name[1]))] )
ani3 <- anisotropie.tensor(mes.sel3, etape.value = 400, TH = TH, volume = mes2.info$vol[which(mes2.info$name == trimws(mes.sel3$name[1]))] )

#plot.ani(c(ani1, ani2, ani3))
Data <- rbind(ani1, ani2, ani3)
point.col <- "forestgreen"

 # restructuration des données
  L1.Inc <- as.numeric(Data[,2])
  L2.Inc <- as.numeric(Data[,5])
  L3.Inc <- as.numeric(Data[,8])
  
  L1.Dec <- as.numeric(Data[,3])
  L2.Dec <- as.numeric(Data[,6])
  L3.Dec <- as.numeric(Data[,9])
  
  if (length(point.col) < length(L1.Inc))
    point.col <- rep(point.col, length.out = length(L1.Inc))
  new <- TRUE
  for (i in 1:length(L1.Inc) ) {
    Da.I <- c(L1.Inc[i], L2.Inc[i], L3.Inc[i])
    Da.D <- c(L1.Dec[i], L2.Dec[i], L3.Dec[i])
    plot.lambert.ID(Da.I,
                    Da.D,
                    inc.lim = c(0, 90), pch = c(22, 24, 21), point.col = point.col[i], new = new  )
    new <- FALSE
  }

```



```{r}
TH <- 60
mes.sel <- NULL
#mes.sel2 <- extract.mesures.specimen.name("19D", mes2)
mes.sel1 <- extract.mesures.specimen.number(1, mes2)
mes.sel2 <- extract.mesures.specimen.number(2, mes2)
mes.sel3 <- extract.mesures.specimen.number(3, mes2)

ani1 <- anisotropie.tensor(mes.sel1, etape.value = 400, TH = TH, volume = mes2.info$vol[which(mes2.info$name == trimws(mes.sel1$name[1]))] )
ani2 <- anisotropie.tensor(mes.sel2, etape.value = 400, TH = TH, volume = mes2.info$vol[which(mes2.info$name == trimws(mes.sel2$name[1]))] )
ani3 <- anisotropie.tensor(mes.sel3, etape.value = 400, TH = TH, volume = mes2.info$vol[which(mes2.info$name == trimws(mes.sel3$name[1]))] )

Data <- rbind(ani1, ani2, ani3)
plot.lambert.ID.tensors(Data, point.col = c("blue", "red", "green"))
#

numbers <- c(7)
Data <- anisotropie.tensors.numbers(numbers, mes2, mes2.info, 400)
plot.lambert.ID.tensors(Data, point.col = c("blue", "red", "green"))


numbers.selected <- NULL
  for (i in 1: length(mes2$number) ) {
    if ( length(which( numbers.selected == mes2$number[i] )) == 0 )
      numbers.selected <- c(numbers.selected, mes2$number[i])
  }

```


```{r test plot.flin }
plot.flin(Data)#, points.col = c("red", "blue"), pt.names = c("titi", "toto"))

```

```{r codage desaimantation}
mes.seltt <- NULL
mes.seltt <- rbind(mes.sel1, mes.sel2)

 
```




```{r}
mes.sel2 <- extract.mesures.specimen.name("1T", mes)
mes.sel3 <- extract.mesures.specimen.name("17T", mes)
desaim(mes.sel2, etap.J0 = NULL)
desaim(mes, etap.J0 = 0, point.col = rainbow(length(mes.info$name)))
desaim(rbind(mes.sel2, mes.sel3), normalize = TRUE)

composante.partielle(mes.sel2$X, mes.sel2$Y, mes.sel2$Z)
```

```{r assemblé}

par(mfrow = c(2, 2), cex.lab = 0.7, cex.axis = .7, cex = 0.7, cex.main = 1, cex.sub = 0.1,
    mai = c(0.5, 0.5, 0.7, 0.3), oma = c(0, 1, 1, 1))#, pty ="s" )
zijderveld1.T1T2(mes.sel2)
zijderveld2.T1T2(mes.sel2)

# suppression des étapes d'anisotropie
mes.sel2 <- supprime.etape(mes.sel2) 
lambert(mes.sel2, inc.lim = c(0, 90))
desaim(mes.sel2, etap.J0 = NULL)
```





```{r genere AMD}
file.AM <- "~/Documents/AM/test.txt"
list.ech <- c("1T",   "17T",  "35T",  "47T",  "50T",  "59T",  "83T",  "87T",  "89T",  "94T",  "100T", "102T", "103T" )
shape <- "Cyl"
entete <- NULL
entete<- c( "Spinner_Molspin 2008" , 
              "Commune : Laval",
              "Site : St Pierre-le-Potier",
              "Latitude  :   0°  0'  0\" ",
              "Longitude :   0°  0'  0\" IGRF:+00.0",
              "Prélèvements sur matériaux déplacés",
              "Type de carottage : à plat",
              "Date de création : 27/05/2019", "","")

txt.mesures <- entete
for (i in 1:length(list.ech)) {
  txt.mesures <- c( txt.mesures,
                    paste("Id:", format(list.ech[i], width = 13), "in:000.0 az:000.0 Tet:000.0 Psy:000.0 v:12.27 com:TH50.0µT ", shape, sep = ""),
                    "Repère:",
                    "CompDes:  T1:0000T+  T2:0000T+  T3:0000T-  T4:0000T-",
                    "")
}


# Ecriture du fichier

filCon <- file(file.AM, encoding="UTF8")
   writeLines(txt.mesures, filCon) 
close(filCon) 
```



# Calcul vecteur partiel
```{r code trace vecteur partiel}
# Procedure Calcul_vecteur_partiel(TabX,TabY,TabZ:array of Real; VAR MAD,SL,Xp,Yp,Zp:Real;en0:boolean;var Xm,Ym,Zm:Real);
# X, Y, Z, les coordonnées cartésiennes du vecteur partiel
en0 <- FALSE
T1 <- 200
T2 <- 400

withAni = FALSE
etape.sigle <- c("Z+", "Z-", "X+", "X-", "Y+", "Y-", "ZB")
mes.sel2 <- extract.mesures.specimen.name("1T", mes)
ani.etape.value <- NULL


res.list <- mes.sel2

if (withAni == FALSE) { # suppression des étape d anisotropie
 if (is.null(ani.etape.value)) {
   for (i in 1:length(Data$Etap)) {
     if (substring(Data$Etap[i], 4) == etape.sigle[3])
       ani.etape.value <- Data$Etap.value[i]
   }
 }
  ani.etape <- trimws(paste(ani.etape.value, etape.sigle, sep = ""))

 
 selec <- NULL
 for (i in 1:length(ani.etape)) {
   selec <- c( selec, which(trimws(mes.sel2$Etap) == trimws(ani.etape[i])) )
 }
 
 if (length(selec) > 0)
    res.list <- mes.sel2[-selec,]
}
         
Data <- res.list
# recherche étape en dessous de T1
iT1 <- 1
while(Data$Etap.value[iT1] < T1) {
  iT1 <- iT1 + 1
}

# recherche étape au dessus de T2
iT2 <- length(Data$Etap.value)
while(Data$Etap.value[iT2] > T2) {
  iT2 <- iT2 -1
}

# Calcul de la composante partielle

TabX <- Data$X[iT1:iT2]
TabY <- Data$Y[iT1:iT2]
TabZ <- Data$Z[iT1:iT2]

vp <- composante.partiel(TabX, TabY, TabZ, en0 = en0)
#ntab <- length(TabX)

 somx <- 0; somy <- 0; somz <- 0
 
 if (en0 == FALSE) {
   somx <- sum(TabX)
   somy <- sum(TabY)
   somz <- sum(TabZ)
 } 
    
  xm <- somx/ ntab
  ym <- somy/ ntab
  zm <- somz/ ntab

  
  
  # a, b : Valeurs indiquant le point d’interception sur l’axe des y et la pente de la droite -> y = a + bx
  # droite sur les déviations
  bd <- vp$X/vp$Y
  ad <- xm - bd*ym
   # droite sur les inclinaisons, +Z est négatif
  bi <- -vp$Z/vp$Y
  ai <- -zm - bi*ym
  
  Y.r <- range(Data$X)
  Z.r <- range(Data$Z)
  ylim <- c(min(Y.r[1], -Z.r[2]), max(Y.r[2], -Z.r[1]))
  
  if (ylim[1]>0)
    ylim[1]<-0
  
  if (ylim[2]<0)
    ylim[2]<-0

  
  zijderveld1(Data$X[1:iT1], Data$Y[1:iT1], Data$Z[1:iT1],  ylim = ylim) 
  zijderveld1(Data$X[iT1:iT2], Data$Y[iT1:iT2], Data$Z[iT1:iT2], pt.col = c("red", "red") , new = FALSE)
  zijderveld1(Data$X[iT2:length(Data$X)], Data$Y[iT2:length(Data$X)], Data$Z[iT2:length(Data$X)], new = FALSE)
  abline(ad, bd)
  abline(ai, bi)
```


```{r code vecteur partiel}
# debut code
vecteur.partiel <- function(TabX, TabY, TabZ, en0 = TRUE) 
{
  col.names <- c("X", "Y", "Z", "I", "D", "F", "Sl", "MAD")
  ntab <- length(TabX);
  
  if ( (ntab<1) || (ntab!=length(TabY)) || (ntab!=length(TabZ))) {
      Data <- c( X = 0, Y = 0, Z = 0,
           I = 0, D = 0, F = 0,
            Sl = NA, MAD = NA )
  
        return(as.data.frame(t(Data), col.names = col.names))  #il faut au moins 2 étapes
  }
       
 # calcul du barycentre du nuage de points si 'en0' false
 somx <- 0; somy <- 0; somz <- 0
 
 if (en0 == FALSE) {
   somx <- sum(TabX)
   somy <- sum(TabY)
   somz <- sum(TabZ)
 } 
    
  xm <- somx/ ntab
  ym <- somy/ ntab
  zm <- somz/ ntab

  Mom <-0; # variable pour Kirschink
  # calcul du moment suivant kischvink
  #  c.à.d. longueur du chemin total entre les points 
  for ( j in 2 : ntab) {
    Mom <- Mom + sqrt( (TabX[j]-TabX[j-1])^2
                       + (TabY[j]-TabY[j-1])^2
                       + (TabZ[j]-TabZ[j-1])^2 )
  }

  # Longueur du plus court chemin
  Sl <- sqrt( (TabX[ntab]-TabX[1])^2
             + (TabY[ntab]-TabY[1])^2
             + (TabZ[ntab]-TabZ[1])^2);
  # Rapport des distances
  Sl <- Sl/Mom;

  
 sxx <- sum((TabX-xm)^2); sxy <- sum((TabX-xm)*(TabY-ym)); sxz <- sum((TabX-xm)*(TabZ-zm))
                          syy <- sum((TabY-ym)^2);         syz <- sum((TabY-ym)*(TabZ-zm))
                                                           szz <- sum((TabZ-zm)^2);
 # Matrice d inertie des points x, y, z pour le calcul de la droite
    Ixx = syy+szz;  Ixy = -sxy;     Ixz = -sxz;
                    Iyy = sxx+szz;  Iyz = -syz;
                                    Izz = sxx+syy;

    
  #  MAD

  mat.sym.norm <- matrix( c( sxx, sxy, sxz,
                             0,  syy, syz,
                             0, 0, szz) , 3, 3)

  # vecteurs et valeurs propres pour MAD
  v.mad <- eigen(mat.sym.norm, symmetric = TRUE)
    
  
  if (( v.mad$values[1] == 0) || ((v.mad$values[2] + v.mad$values[3])/ v.mad$values[1] < 0)) {
    warning('MAD non calculable')
    MAD <- NA
  } else {
    MAD <- atan(sqrt( ((v.mad$values[2] + v.mad$values[3])/ v.mad$values[1]) ));
  } 

  #   Calcul composante partielle
  # Matrice d'inertie des points x,y,z

  # La direction correspond au vecteur propre minimum
  mat.sym.norm <- matrix( c( Ixx , Ixy , Ixz ,
                             0,  Iyy , Iyz ,
                             0, 0, Izz ) , 3, 3)
  
  # vecteurs et valeurs propres pour MAD
  v.cp <- eigen(mat.sym.norm, symmetric = TRUE)
  v3 <- polaire(v.cp$vectors[1, 3],  v.cp$vectors[2, 3],  v.cp$vectors[3 ,3])
  
  vcorrect<- NULL
  vcorrect$I <- sign(TabZ[1] - TabZ[ntab]) * abs(v3$I)
  vcorrect$D <- v3$D
  
  if (sign(vcorrect$I) !=  sign(v3$I)) {
    vcorrect$D <- D.AM(v3$D +180)
  }
 
 
 # mise en forme du résultat
  MAD <- MAD * 180 /pi 
  
 col.names <- c("X", "Y", "Z", "I", "D", "F", "Sl", "MAD")
 Data <- c( X = v.cp$vectors[1, 3], Y = v.cp$vectors[2, 3], Z = v.cp$vectors[3, 3],
          I = vcorrect$I, D = vcorrect$D, F = v3$F,
          Sl = Sl, MAD = MAD )

 #res <- as.data.frame(t(Data), col.names = col.names)
 return(as.data.frame(t(Data), col.names = col.names))
}

```

```{r composante de tout le site}
sp.res <- NULL
for (sp in 1: length(mes.info$number)){
  sp.mes <- extract.mesures.specimen.number(mes.info$number[sp], mes)


  # correction d'anisotropie
  volume <- mes.info$vol[which(mes.info$name == trimws(mes.sp$name[1]))]
  TH <- mes.info$TH[which(mes.info$name == trimws(mes.sp$name[1]))]
  
  # normalisation des mesures en A/m
  sp.mes$X <- sp.mes$X /volume * 1E6
  sp.mes$Y <- sp.mes$Y /volume * 1E6
  sp.mes$Z <- sp.mes$Z /volume * 1E6
  
  # récupération de l'ARN
  #sp.mes.ARN <- sp.mes[sp.mes$Etap.value == 0,]
  

  # évaluation de l'anisotropie
  sp.ani <- anisotropie.matrix.symetric(sp.mes, etape.value = 500, TH = TH, volume = volume )
 
  # suppression des étapes d'anisotropie
  sp.mes <- supprime.etape(sp.mes) 
    
  # correction de l'anisotropie  
  sp.cor <- correction.anisotropie(sp.mes, sp.ani)
  
  # determination de la composante
  sp.cp <- composante.partielle(sp.cor$X, sp.cor$Y, sp.cor$Z)
  
  # repliement
  sp.cp <- repliement.auto(sp.cp$I, sp.cp$D, name = sp.mes$name)
  sp.res <- rbind.data.frame(sp.res, cbind(name =mes.info$name[sp], sp.cp) )
}


stat.mcFadden(sp.res$I, sp.res$D)


lambert(sp.res, inc.lim = c(0,90))
```
