KF <- ((n-1)/n) * KF
print( "KF", KF)
delta <- log(1+(1-pfish) * (exp(2*KF)-1)) /KF
delta <- acos(delta-1)
pfish<-0.95
n <- length(inc)
if (length(dec) != n) {
return("length (dec) diff length(inc)")
}
if (is.na(aim) || length(aim) != n) {
aim <- rep(1, n)
}
sx <- sum(aim*cos(inc/180*pi)*sin(dec/180*pi))
sy <- sum(aim*cos(inc/180*pi)*cos(dec/180*pi))
sz <- sum(aim*sin(inc/180*pi))
sn <- sum(aim)
r <- sqrt(sx*sx+sy*sy+sz*sz)
imoy <- N_ARCSIN(sz/r)
dmoy <-AngleD(sx,sy)
KF <- sn/(sn-r)
# Calcul de A95 Vrai sans simplification tel que fisher 1953
a95 <- exp( (1/(n-1))* log(1/(1-pfish)) )
a95 <- (a95 -1 )*(n-r)/r
a95 <- acos(1-a95)
print( "a95 Fisher 1953", a95)
# correction du biais
KF <- ((n-1)/n) * KF
print( "KF", KF)
delta <- log(1+(1-pfish) * (exp(2*KF)-1)) /KF
delta <- acos(delta-1)
a95
a95*180/pi
stat.fisher <- function (inc, dec, aim=NA, pfish = 0.95) {
n <- length(inc)
if (length(dec) != n) {
return("length (dec) diff length(inc)")
}
if (is.na(aim) || length(aim) != n) {
aim <- rep(1, n)
}
sx <- sum(aim*cos(inc/180*pi)*sin(dec/180*pi))
sy <- sum(aim*cos(inc/180*pi)*cos(dec/180*pi))
sz <- sum(aim*sin(inc/180*pi))
sn <- sum(aim)
r <- sqrt(sx*sx+sy*sy+sz*sz)
imoy <- N_ARCSIN(sz/r)
dmoy <-AngleD(sx,sy)
KF <- sn/(sn-r)
# Calcul de A95 Vrai sans simplification tel que fisher 1953
a95 <- exp( (1/(n-1))* log(1/(1-pfish)) )
a95 <- (a95 -1 )*(n-r)/r
a95 <- acos(1-a95)
print( "a95 Fisher 1953", a95)
# correction du biais
KF <- ((n-1)/n) * KF
print( "KF", KF)
delta <- log(1+(1-pfish) * (exp(2*KF)-1)) /KF
delta <- acos(delta-1)
return(c(n=n, imoy =imoy, dmoy = dmoy, a95=a95/pi*180, delta = delta/pi*180) )
}
stat.fisher(i, d)
N_ARCSIN <- function(x) {
n <- NA
if (abs(x)<1)
n <- atan(X/sqrt(1-X*X))
else {
if (x>=1)
n <- pi/2
else
n <- -pi/2
}
return(n)
}
stat.fisher(i, d)
N_ARCSIN <- function(x) {
n <- NA
if (abs(x)<1)
n <- atan(X/sqrt(1-x*x))
else {
if (x>=1)
n <- pi/2
else
n <- -pi/2
}
return(n)
}
stat.fisher(i, d)
N_ARCSIN <- function(x) {
n <- NA
if (abs(x)<1)
n <- atan(x/sqrt(1-x*x))
else {
if (x>=1)
n <- pi/2
else
n <- -pi/2
}
return(n)
}
stat.fisher(i, d)
AngleD <- function(X,Y){
if (X == 0)
AngleD <- sign(Y)*pi/2
else {
AngleD <- atan(Y/X)
if (X<0)
AngleD <- AngleD + pi
}
return(AngleD)
}
stat.fisher(i, d)
stat.fisher <- function (inc, dec, aim=NA, pfish = 0.95) {
n <- length(inc)
if (length(dec) != n) {
return("length (dec) diff length(inc)")
}
if (is.na(aim) || length(aim) != n) {
aim <- rep(1, n)
}
sx <- sum(aim*cos(inc/180*pi)*sin(dec/180*pi))
sy <- sum(aim*cos(inc/180*pi)*cos(dec/180*pi))
sz <- sum(aim*sin(inc/180*pi))
sn <- sum(aim)
r <- sqrt(sx*sx+sy*sy+sz*sz)
imoy <- N_ARCSIN(sz/r)
dmoy <-AngleD(sx,sy)
KF <- sn/(sn-r)
# Calcul de A95 Vrai sans simplification tel que fisher 1953
a95 <- exp( (1/(n-1))* log(1/(1-pfish)) )
a95 <- (a95 -1 )*(n-r)/r
a95 <- acos(1-a95)
print( paste("alpha", pfish*100," Fisher 1953", a95/pi*180))
# correction du biais
KF <- ((n-1)/n) * KF
print( paste("KF", KF))
delta <- log(1+(1-pfish) * (exp(2*KF)-1)) /KF
delta <- acos(delta-1)
return(c(n=n, imoy =imoy/pi*180, dmoy = dmoy/pi*180, a95=a95/pi*180, delta = delta/pi*180, KF = KF) )
}
stat.fisher(i, d)
stat.fisher(i, d, pfish = 0.5)
stat.fisher <- function (inc, dec, aim=NA, pfish = 0.95) {
n <- length(inc)
if (length(dec) != n) {
return("length (dec) diff length(inc)")
}
if (is.na(aim) || length(aim) != n) {
aim <- rep(1, n)
}
sx <- sum(aim*cos(inc/180*pi)*sin(dec/180*pi))
sy <- sum(aim*cos(inc/180*pi)*cos(dec/180*pi))
sz <- sum(aim*sin(inc/180*pi))
sn <- sum(aim)
r <- sqrt(sx*sx+sy*sy+sz*sz)
imoy <- N_ARCSIN(sz/r)
dmoy <-AngleD(sx,sy)
KF <- sn/(sn-r)
# Calcul de A95 Vrai sans simplification tel que fisher 1953
a95 <- exp( (1/(n-1))* log(1/(1-pfish)) )
a95 <- (a95 -1 )*(n-r)/r
a95 <- acos(1-a95)
print( paste("Inc Moy ", imoy/pi*180,"° Dec Moy ", dmoy/pi*180, "°"))
print( paste("alpha", pfish*100,"% Fisher 1953 : ", a95/pi*180))
# correction du biais
KF <- ((n-1)/n) * KF
print( paste("KF :", KF))
delta <- log(1+(1-pfish) * (exp(2*KF)-1)) /KF
delta <- acos(delta-1)
return(c(n=n, imoy =imoy/pi*180, dmoy = dmoy/pi*180, alpha=a95/pi*180, pfish = pfish, delta = delta/pi*180, KF = KF) )
}
stat.fisher(i, d, pfish = 0.5)
sf<-stat.fisher(i, d, pfish = 0.5)
sf
sf$n
sf[1]
summary(sf)
source('~/Documents/AM/R_Projects/Tracer_IDF/lambert_function.R', echo=TRUE)
source('~/Documents/AM/R_Projects/Tracer_IDF/lambert_function.R', echo=TRUE)
radl = FALSE
par(cex.axis=1.0) # défini la taille des caractères des graduations
radl = FALSE
lambertID(IDF$I, IDF$D, clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test Symbols (clockwise)", inc.lim=c(inc.min = 10, inc.max = 80), point.symbols=16, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = -80, dec.max = 10, radlab = radl)
lambertID(c(50, 45), c(-30, -40), clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test Symbols (clockwise)", inc.lim=c(inc.min = 10, inc.max = 80), point.symbols=16, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = 10, dec.max = 100, radlab = radl)
lambertID(c(70, 40), c(120, 140), clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test Symbols (clockwise)", inc.lim=c(inc.min = 10, inc.max = 80), point.symbols=16, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = 110, dec.max = 200, radlab = radl)
lambertID(c(30, 45), c(20, -40), clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test 2 points", inc.lim =c(inc.min = 0, inc.max = 90), point.symbols=19, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = 190, dec.max = 270, radlab = radl)
par(cex.axis=0.5) # défini la taille des caractères des graduations
radl = FALSE
lambertID(IDF$I, IDF$D, clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test Symbols (clockwise)", inc.lim=c(inc.min = 10, inc.max = 80), point.symbols=16, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = -80, dec.max = 10, radlab = radl)
lambertID(c(50, 45), c(-30, -40), clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test Symbols (clockwise)", inc.lim=c(inc.min = 10, inc.max = 80), point.symbols=16, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = 10, dec.max = 100, radlab = radl)
lambertID(c(70, 40), c(120, 140), clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test Symbols (clockwise)", inc.lim=c(inc.min = 10, inc.max = 80), point.symbols=16, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = 110, dec.max = 200, radlab = radl)
lambertID(c(30, 45), c(20, -40), clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test 2 points", inc.lim =c(inc.min = 0, inc.max = 90), point.symbols=19, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = 190, dec.max = 270, radlab = radl)
par(cex.axis=1.0) # défini la taille des caractères des graduations
radl = FALSE
lambertID(IDF$I, IDF$D, clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test Symbols (clockwise)", inc.lim=c(inc.min = 10, inc.max = 80), point.symbols=16, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = -80, dec.max = 10, radlab = radl)
lambertID(c(50, 45), c(-30, -40), clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test Symbols (clockwise)", inc.lim=c(inc.min = 10, inc.max = 80), point.symbols=16, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = 10, dec.max = 100, radlab = radl)
lambertID(c(70, 40), c(120, 140), clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test Symbols (clockwise)", inc.lim=c(inc.min = 10, inc.max = 80), point.symbols=16, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = 110, dec.max = 200, radlab = radl)
lambertID(c(30, 45), c(20, -40), clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test 2 points", inc.lim =c(inc.min = 0, inc.max = 90), point.symbols=19, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = 190, dec.max = 270, radlab = radl)
par(cex.axis=1.0,cex.lab=3) # défini la taille des caractères des graduations
radl = FALSE
lambertID(IDF$I, IDF$D, clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test Symbols (clockwise)", inc.lim=c(inc.min = 10, inc.max = 80), point.symbols=16, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = -80, dec.max = 10, radlab = radl)
lambertID(c(50, 45), c(-30, -40), clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test Symbols (clockwise)", inc.lim=c(inc.min = 10, inc.max = 80), point.symbols=16, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = 10, dec.max = 100, radlab = radl)
lambertID(c(70, 40), c(120, 140), clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test Symbols (clockwise)", inc.lim=c(inc.min = 10, inc.max = 80), point.symbols=16, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = 110, dec.max = 200, radlab = radl)
lambertID(c(30, 45), c(20, -40), clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test 2 points", inc.lim =c(inc.min = 0, inc.max = 90), point.symbols=19, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = 190, dec.max = 270, radlab = radl)
par(cex.axis=1.0,bty="n") # défini la taille des caractères des graduations
radl = FALSE
lambertID(IDF$I, IDF$D, clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test Symbols (clockwise)", inc.lim=c(inc.min = 10, inc.max = 80), point.symbols=16, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = -80, dec.max = 10, radlab = radl)
lambertID(c(50, 45), c(-30, -40), clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test Symbols (clockwise)", inc.lim=c(inc.min = 10, inc.max = 80), point.symbols=16, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = 10, dec.max = 100, radlab = radl)
lambertID(c(70, 40), c(120, 140), clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test Symbols (clockwise)", inc.lim=c(inc.min = 10, inc.max = 80), point.symbols=16, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = 110, dec.max = 200, radlab = radl)
lambertID(c(30, 45), c(20, -40), clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test 2 points", inc.lim =c(inc.min = 0, inc.max = 90), point.symbols=19, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = 190, dec.max = 270, radlab = radl)
par(cex.axis=1.0, lty=1:2) # défini la taille des caractères des graduations
par(cex.axis=1.0, lty=1) # défini la taille des caractères des graduations
radl = FALSE
lambertID(IDF$I, IDF$D, clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test Symbols (clockwise)", inc.lim=c(inc.min = 10, inc.max = 80), point.symbols=16, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = -80, dec.max = 10, radlab = radl)
lambertID(c(50, 45), c(-30, -40), clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test Symbols (clockwise)", inc.lim=c(inc.min = 10, inc.max = 80), point.symbols=16, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = 10, dec.max = 100, radlab = radl)
lambertID(c(70, 40), c(120, 140), clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test Symbols (clockwise)", inc.lim=c(inc.min = 10, inc.max = 80), point.symbols=16, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = 110, dec.max = 200, radlab = radl)
lambertID(c(30, 45), c(20, -40), clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test 2 points", inc.lim =c(inc.min = 0, inc.max = 90), point.symbols=19, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = 190, dec.max = 270, radlab = radl)
par(cex.axis=1.0, lty=5) # défini la taille des caractères des graduations
radl = FALSE
lambertID(IDF$I, IDF$D, clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test Symbols (clockwise)", inc.lim=c(inc.min = 10, inc.max = 80), point.symbols=16, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = -80, dec.max = 10, radlab = radl)
lambertID(c(50, 45), c(-30, -40), clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test Symbols (clockwise)", inc.lim=c(inc.min = 10, inc.max = 80), point.symbols=16, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = 10, dec.max = 100, radlab = radl)
lambertID(c(70, 40), c(120, 140), clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test Symbols (clockwise)", inc.lim=c(inc.min = 10, inc.max = 80), point.symbols=16, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = 110, dec.max = 200, radlab = radl)
lambertID(c(30, 45), c(20, -40), clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test 2 points", inc.lim =c(inc.min = 0, inc.max = 90), point.symbols=19, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = 190, dec.max = 270, radlab = radl)
par(cex.axis=1.0, lty=3) # défini la taille des caractères des graduations
radl = FALSE
lambertID(IDF$I, IDF$D, clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test Symbols (clockwise)", inc.lim=c(inc.min = 10, inc.max = 80), point.symbols=16, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = -80, dec.max = 10, radlab = radl)
lambertID(c(50, 45), c(-30, -40), clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test Symbols (clockwise)", inc.lim=c(inc.min = 10, inc.max = 80), point.symbols=16, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = 10, dec.max = 100, radlab = radl)
lambertID(c(70, 40), c(120, 140), clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test Symbols (clockwise)", inc.lim=c(inc.min = 10, inc.max = 80), point.symbols=16, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = 110, dec.max = 200, radlab = radl)
lambertID(c(30, 45), c(20, -40), clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test 2 points", inc.lim =c(inc.min = 0, inc.max = 90), point.symbols=19, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = 190, dec.max = 270, radlab = radl)
par(cex.axis=1.0, lty=4) # cex.axis : défini la taille des caractères des graduations; lty : défini les pointillés
radl = FALSE
lambertID(IDF$I, IDF$D, clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test Symbols (clockwise)", inc.lim=c(inc.min = 10, inc.max = 80), point.symbols=16, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = -80, dec.max = 10, radlab = radl)
lambertID(c(50, 45), c(-30, -40), clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test Symbols (clockwise)", inc.lim=c(inc.min = 10, inc.max = 80), point.symbols=16, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = 10, dec.max = 100, radlab = radl)
lambertID(c(70, 40), c(120, 140), clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test Symbols (clockwise)", inc.lim=c(inc.min = 10, inc.max = 80), point.symbols=16, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = 110, dec.max = 200, radlab = radl)
lambertID(c(30, 45), c(20, -40), clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test 2 points", inc.lim =c(inc.min = 0, inc.max = 90), point.symbols=19, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = 190, dec.max = 270, radlab = radl)
par(cex.axis=1.0, lty=5) # cex.axis : défini la taille des caractères des graduations; lty : défini les pointillés
radl = FALSE
lambertID(IDF$I, IDF$D, clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test Symbols (clockwise)", inc.lim=c(inc.min = 10, inc.max = 80), point.symbols=16, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = -80, dec.max = 10, radlab = radl)
lambertID(c(50, 45), c(-30, -40), clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test Symbols (clockwise)", inc.lim=c(inc.min = 10, inc.max = 80), point.symbols=16, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = 10, dec.max = 100, radlab = radl)
lambertID(c(70, 40), c(120, 140), clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test Symbols (clockwise)", inc.lim=c(inc.min = 10, inc.max = 80), point.symbols=16, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = 110, dec.max = 200, radlab = radl)
lambertID(c(30, 45), c(20, -40), clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test 2 points", inc.lim =c(inc.min = 0, inc.max = 90), point.symbols=19, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = 190, dec.max = 270, radlab = radl)
par(cex.axis=1.0, lty=2) # cex.axis : défini la taille des caractères des graduations; lty : défini les pointillés
radl = FALSE
lambertID(IDF$I, IDF$D, clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test Symbols (clockwise)", inc.lim=c(inc.min = 10, inc.max = 80), point.symbols=16, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = -80, dec.max = 10, radlab = radl)
lambertID(c(50, 45), c(-30, -40), clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test Symbols (clockwise)", inc.lim=c(inc.min = 10, inc.max = 80), point.symbols=16, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = 10, dec.max = 100, radlab = radl)
lambertID(c(70, 40), c(120, 140), clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test Symbols (clockwise)", inc.lim=c(inc.min = 10, inc.max = 80), point.symbols=16, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = 110, dec.max = 200, radlab = radl)
lambertID(c(30, 45), c(20, -40), clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test 2 points", inc.lim =c(inc.min = 0, inc.max = 90), point.symbols=19, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = 190, dec.max = 270, radlab = radl)
par(cex.axis=1.0, lty=20) # cex.axis : défini la taille des caractères des graduations; lty : défini les pointillés
radl = FALSE
lambertID(IDF$I, IDF$D, clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test Symbols (clockwise)", inc.lim=c(inc.min = 10, inc.max = 80), point.symbols=16, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = -80, dec.max = 10, radlab = radl)
lambertID(c(50, 45), c(-30, -40), clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test Symbols (clockwise)", inc.lim=c(inc.min = 10, inc.max = 80), point.symbols=16, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = 10, dec.max = 100, radlab = radl)
lambertID(c(70, 40), c(120, 140), clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test Symbols (clockwise)", inc.lim=c(inc.min = 10, inc.max = 80), point.symbols=16, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = 110, dec.max = 200, radlab = radl)
lambertID(c(30, 45), c(20, -40), clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test 2 points", inc.lim =c(inc.min = 0, inc.max = 90), point.symbols=19, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = 190, dec.max = 270, radlab = radl)
par(cex.axis=1.0, lty=10) # cex.axis : défini la taille des caractères des graduations; lty : défini les pointillés
radl = FALSE
lambertID(IDF$I, IDF$D, clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test Symbols (clockwise)", inc.lim=c(inc.min = 10, inc.max = 80), point.symbols=16, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = -80, dec.max = 10, radlab = radl)
lambertID(c(50, 45), c(-30, -40), clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test Symbols (clockwise)", inc.lim=c(inc.min = 10, inc.max = 80), point.symbols=16, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = 10, dec.max = 100, radlab = radl)
lambertID(c(70, 40), c(120, 140), clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test Symbols (clockwise)", inc.lim=c(inc.min = 10, inc.max = 80), point.symbols=16, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = 110, dec.max = 200, radlab = radl)
lambertID(c(30, 45), c(20, -40), clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test 2 points", inc.lim =c(inc.min = 0, inc.max = 90), point.symbols=19, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = 190, dec.max = 270, radlab = radl)
par(cex.axis=1.0, lty=8) # cex.axis : défini la taille des caractères des graduations; lty : défini les pointillés
radl = FALSE
lambertID(IDF$I, IDF$D, clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test Symbols (clockwise)", inc.lim=c(inc.min = 10, inc.max = 80), point.symbols=16, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = -80, dec.max = 10, radlab = radl)
lambertID(c(50, 45), c(-30, -40), clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test Symbols (clockwise)", inc.lim=c(inc.min = 10, inc.max = 80), point.symbols=16, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = 10, dec.max = 100, radlab = radl)
lambertID(c(70, 40), c(120, 140), clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test Symbols (clockwise)", inc.lim=c(inc.min = 10, inc.max = 80), point.symbols=16, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = 110, dec.max = 200, radlab = radl)
lambertID(c(30, 45), c(20, -40), clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test 2 points", inc.lim =c(inc.min = 0, inc.max = 90), point.symbols=19, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = 190, dec.max = 270, radlab = radl)
par(cex.axis=1.0, lty=6) # cex.axis : défini la taille des caractères des graduations; lty : défini les pointillés
radl = FALSE
lambertID(IDF$I, IDF$D, clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test Symbols (clockwise)", inc.lim=c(inc.min = 10, inc.max = 80), point.symbols=16, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = -80, dec.max = 10, radlab = radl)
lambertID(c(50, 45), c(-30, -40), clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test Symbols (clockwise)", inc.lim=c(inc.min = 10, inc.max = 80), point.symbols=16, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = 10, dec.max = 100, radlab = radl)
lambertID(c(70, 40), c(120, 140), clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test Symbols (clockwise)", inc.lim=c(inc.min = 10, inc.max = 80), point.symbols=16, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = 110, dec.max = 200, radlab = radl)
lambertID(c(30, 45), c(20, -40), clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test 2 points", inc.lim =c(inc.min = 0, inc.max = 90), point.symbols=19, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = 190, dec.max = 270, radlab = radl)
par(cex.axis=1.0, lty=1) # cex.axis : défini la taille des caractères des graduations; lty : défini les pointillés
radl = FALSE
lambertID(IDF$I, IDF$D, clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test Symbols (clockwise)", inc.lim=c(inc.min = 10, inc.max = 80), point.symbols=16, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = -80, dec.max = 10, radlab = radl)
lambertID(c(50, 45), c(-30, -40), clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test Symbols (clockwise)", inc.lim=c(inc.min = 10, inc.max = 80), point.symbols=16, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = 10, dec.max = 100, radlab = radl)
lambertID(c(70, 40), c(120, 140), clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test Symbols (clockwise)", inc.lim=c(inc.min = 10, inc.max = 80), point.symbols=16, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = 110, dec.max = 200, radlab = radl)
lambertID(c(30, 45), c(20, -40), clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test 2 points", inc.lim =c(inc.min = 0, inc.max = 90), point.symbols=19, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = 190, dec.max = 270, radlab = radl)
par(cex.axis=1.0, lty=17) # cex.axis : défini la taille des caractères des graduations; lty : défini les pointillés
radl = FALSE
lambertID(IDF$I, IDF$D, clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test Symbols (clockwise)", inc.lim=c(inc.min = 10, inc.max = 80), point.symbols=16, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = -80, dec.max = 10, radlab = radl)
lambertID(c(50, 45), c(-30, -40), clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test Symbols (clockwise)", inc.lim=c(inc.min = 10, inc.max = 80), point.symbols=16, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = 10, dec.max = 100, radlab = radl)
lambertID(c(70, 40), c(120, 140), clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test Symbols (clockwise)", inc.lim=c(inc.min = 10, inc.max = 80), point.symbols=16, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = 110, dec.max = 200, radlab = radl)
lambertID(c(30, 45), c(20, -40), clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test 2 points", inc.lim =c(inc.min = 0, inc.max = 90), point.symbols=19, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = 190, dec.max = 270, radlab = radl)
par(cex.axis=1.0, lty=6) # cex.axis : défini la taille des caractères des graduations; lty : défini les pointillés
radl = FALSE
lambertID(IDF$I, IDF$D, clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test Symbols (clockwise)", inc.lim=c(inc.min = 10, inc.max = 80), point.symbols=16, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = -80, dec.max = 10, radlab = radl)
lambertID(c(50, 45), c(-30, -40), clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test Symbols (clockwise)", inc.lim=c(inc.min = 10, inc.max = 80), point.symbols=16, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = 10, dec.max = 100, radlab = radl)
lambertID(c(70, 40), c(120, 140), clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test Symbols (clockwise)", inc.lim=c(inc.min = 10, inc.max = 80), point.symbols=16, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = 110, dec.max = 200, radlab = radl)
lambertID(c(30, 45), c(20, -40), clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test 2 points", inc.lim =c(inc.min = 0, inc.max = 90), point.symbols=19, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = 190, dec.max = 270, radlab = radl)
par(cex.axis=1.0, lty=2, lab=c(5, 7, 12))
# cex.axis : défini la taille des caractères des graduations; L'expansion des caractères. La valeur est la taille désirée de caractères de texte par rapport à la taille du texte par défaut.
# lty : (ligne type) Types de lignes. Le type 1 est toujours une ligne solide, le type 0 : type de ligne toujours invisible, et le type 2 : lignes en pointillés, en petit tiret ou les 2 à la fois.
radl = FALSE
lambertID(IDF$I, IDF$D, clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test Symbols (clockwise)", inc.lim=c(inc.min = 10, inc.max = 80), point.symbols=16, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = -80, dec.max = 10, radlab = radl)
lambertID(c(50, 45), c(-30, -40), clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test Symbols (clockwise)", inc.lim=c(inc.min = 10, inc.max = 80), point.symbols=16, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = 10, dec.max = 100, radlab = radl)
lambertID(c(70, 40), c(120, 140), clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test Symbols (clockwise)", inc.lim=c(inc.min = 10, inc.max = 80), point.symbols=16, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = 110, dec.max = 200, radlab = radl)
lambertID(c(30, 45), c(20, -40), clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test 2 points", inc.lim =c(inc.min = 0, inc.max = 90), point.symbols=19, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = 190, dec.max = 270, radlab = radl)
par(cex.axis=1.0, lty=2, lab=c(1, 1, 1))
# cex.axis : défini la taille des caractères des graduations; L'expansion des caractères. La valeur est la taille désirée de caractères de texte par rapport à la taille du texte par défaut.
# lty : (ligne type) Types de lignes. Le type 1 est toujours une ligne solide, le type 0 : type de ligne toujours invisible, et le type 2 : lignes en pointillés, en petit tiret ou les 2 à la fois.
radl = FALSE
lambertID(IDF$I, IDF$D, clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test Symbols (clockwise)", inc.lim=c(inc.min = 10, inc.max = 80), point.symbols=16, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = -80, dec.max = 10, radlab = radl)
lambertID(c(50, 45), c(-30, -40), clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test Symbols (clockwise)", inc.lim=c(inc.min = 10, inc.max = 80), point.symbols=16, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = 10, dec.max = 100, radlab = radl)
lambertID(c(70, 40), c(120, 140), clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test Symbols (clockwise)", inc.lim=c(inc.min = 10, inc.max = 80), point.symbols=16, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = 110, dec.max = 200, radlab = radl)
lambertID(c(30, 45), c(20, -40), clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test 2 points", inc.lim =c(inc.min = 0, inc.max = 90), point.symbols=19, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = 190, dec.max = 270, radlab = radl)
par(cex.axis=1.0, lty=2, adj=-0.5)
par(cex.axis=1.0, lty=2, adj=0.5)
# cex.axis : défini la taille des caractères des graduations; L'expansion des caractères. La valeur est la taille désirée de caractères de texte par rapport à la taille du texte par défaut.
# lty : (ligne type) Types de lignes. Le type 1 est toujours une ligne solide, le type 0 : type de ligne toujours invisible, et le type 2 : lignes en pointillés, en petit tiret ou les 2 à la fois.
radl = FALSE
lambertID(IDF$I, IDF$D, clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test Symbols (clockwise)", inc.lim=c(inc.min = 10, inc.max = 80), point.symbols=16, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = -80, dec.max = 10, radlab = radl)
lambertID(c(50, 45), c(-30, -40), clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test Symbols (clockwise)", inc.lim=c(inc.min = 10, inc.max = 80), point.symbols=16, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = 10, dec.max = 100, radlab = radl)
lambertID(c(70, 40), c(120, 140), clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test Symbols (clockwise)", inc.lim=c(inc.min = 10, inc.max = 80), point.symbols=16, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = 110, dec.max = 200, radlab = radl)
lambertID(c(30, 45), c(20, -40), clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test 2 points", inc.lim =c(inc.min = 0, inc.max = 90), point.symbols=19, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = 190, dec.max = 270, radlab = radl)
font.axis
par(cex.axis=1.0, lty=2, lwi=5)
# cex.axis : défini la taille des caractères des graduations; L'expansion des caractères. La valeur est la taille désirée de caractères de texte par rapport à la taille du texte par défaut.
# lty : (ligne type) Types de lignes. Le type 1 est toujours une ligne solide, le type 0 : type de ligne toujours invisible, et le type 2 : lignes en pointillés, en petit tiret ou les 2 à la fois.
radl = FALSE
lambertID(IDF$I, IDF$D, clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test Symbols (clockwise)", inc.lim=c(inc.min = 10, inc.max = 80), point.symbols=16, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = -80, dec.max = 10, radlab = radl)
lambertID(c(50, 45), c(-30, -40), clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test Symbols (clockwise)", inc.lim=c(inc.min = 10, inc.max = 80), point.symbols=16, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = 10, dec.max = 100, radlab = radl)
lambertID(c(70, 40), c(120, 140), clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test Symbols (clockwise)", inc.lim=c(inc.min = 10, inc.max = 80), point.symbols=16, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = 110, dec.max = 200, radlab = radl)
lambertID(c(30, 45), c(20, -40), clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test 2 points", inc.lim =c(inc.min = 0, inc.max = 90), point.symbols=19, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = 190, dec.max = 270, radlab = radl)
par(cex.axis=1.0, lty=2, lwd=5)
# cex.axis : défini la taille des caractères des graduations; L'expansion des caractères. La valeur est la taille désirée de caractères de texte par rapport à la taille du texte par défaut.
# lty : (ligne type) Types de lignes. Le type 1 est toujours une ligne solide, le type 0 : type de ligne toujours invisible, et le type 2 : lignes en pointillés, en petit tiret ou les 2 à la fois.
radl = FALSE
lambertID(IDF$I, IDF$D, clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test Symbols (clockwise)", inc.lim=c(inc.min = 10, inc.max = 80), point.symbols=16, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = -80, dec.max = 10, radlab = radl)
lambertID(c(50, 45), c(-30, -40), clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test Symbols (clockwise)", inc.lim=c(inc.min = 10, inc.max = 80), point.symbols=16, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = 10, dec.max = 100, radlab = radl)
lambertID(c(70, 40), c(120, 140), clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test Symbols (clockwise)", inc.lim=c(inc.min = 10, inc.max = 80), point.symbols=16, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = 110, dec.max = 200, radlab = radl)
lambertID(c(30, 45), c(20, -40), clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test 2 points", inc.lim =c(inc.min = 0, inc.max = 90), point.symbols=19, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = 190, dec.max = 270, radlab = radl)
par(cex.axis=1.0, lty=2, lwd=0.5)
# cex.axis : défini la taille des caractères des graduations; L'expansion des caractères. La valeur est la taille désirée de caractères de texte par rapport à la taille du texte par défaut.
# lty : (ligne type) Types de lignes. Le type 1 est toujours une ligne solide, le type 0 : type de ligne toujours invisible, et le type 2 : lignes en pointillés, en petit tiret ou les 2 à la fois.
# lwd : taille des traits
radl = FALSE
lambertID(IDF$I, IDF$D, clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test Symbols (clockwise)", inc.lim=c(inc.min = 10, inc.max = 80), point.symbols=16, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = -80, dec.max = 10, radlab = radl)
lambertID(c(50, 45), c(-30, -40), clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test Symbols (clockwise)", inc.lim=c(inc.min = 10, inc.max = 80), point.symbols=16, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = 10, dec.max = 100, radlab = radl)
lambertID(c(70, 40), c(120, 140), clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test Symbols (clockwise)", inc.lim=c(inc.min = 10, inc.max = 80), point.symbols=16, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = 110, dec.max = 200, radlab = radl)
lambertID(c(30, 45), c(20, -40), clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test 2 points", inc.lim =c(inc.min = 0, inc.max = 90), point.symbols=19, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = 190, dec.max = 270, radlab = radl)
locator
locator()
par(cex.axis=1.0, lty=2, lwd=0.5)
# cex.axis : défini la taille des caractères des graduations; L'expansion des caractères. La valeur est la taille désirée de caractères de texte par rapport à la taille du texte par défaut.
# lty : (ligne type) Types de lignes. Le type 1 est toujours une ligne solide, le type 0 : type de ligne toujours invisible, et le type 2 : lignes en pointillés, en petit tiret ou les 2 à la fois.
# lwd : taille des traits
radl = FALSE
lambertID(IDF$I, IDF$D, clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test Symbols (clockwise)", inc.lim=c(inc.min = 10, inc.max = 80), point.symbols=16, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = -80, dec.max = 10, radlab = radl)
lambertID(c(50, 45), c(-30, -40), clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test Symbols (clockwise)", inc.lim=c(inc.min = 10, inc.max = 80), point.symbols=16, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = 10, dec.max = 100, radlab = radl)
lambertID(c(70, 40), c(120, 140), clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test Symbols (clockwise)", inc.lim=c(inc.min = 10, inc.max = 80), point.symbols=16, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = 110, dec.max = 200, radlab = radl)
locator(lambertID(c(30, 45), c(20, -40), clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test 2 points", inc.lim =c(inc.min = 0, inc.max = 90), point.symbols=19, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = 190, dec.max = 270, radlab = radl))
par(cex.axis=1.0, lty=2, lwd=0.5)
# cex.axis : défini la taille des caractères des graduations; L'expansion des caractères. La valeur est la taille désirée de caractères de texte par rapport à la taille du texte par défaut.
# lty : (ligne type) Types de lignes. Le type 1 est toujours une ligne solide, le type 0 : type de ligne toujours invisible, et le type 2 : lignes en pointillés, en petit tiret ou les 2 à la fois.
# lwd : taille des traits
radl = FALSE
lambertID(IDF$I, IDF$D, clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test Symbols (clockwise)", inc.lim=c(inc.min = 10, inc.max = 80), point.symbols=16, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = -80, dec.max = 10, radlab = radl)
lambertID(c(50, 45), c(-30, -40), clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test Symbols (clockwise)", inc.lim=c(inc.min = 10, inc.max = 80), point.symbols=16, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = 10, dec.max = 100, radlab = radl)
lambertID(c(70, 40), c(120, 140), clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test Symbols (clockwise)", inc.lim=c(inc.min = 10, inc.max = 80), point.symbols=16, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = 110, dec.max = 200, radlab = radl)
lambertID(c(30, 45), c(20, -40), clockwise=TRUE, show.grid.labels=TRUE, rp.type="s", main="Test 2 points", inc.lim =c(inc.min = 0, inc.max = 90), point.symbols=19, point.col="green", show.grid = TRUE, grid.col= "blue", dec.min = 190, dec.max = 270, radlab = radl)
locator(n = 512, type = "n", ...)
par(cex.axis=1.0, lty=2, lwd=0.5)
# cex.axis : défini la taille des caractères des graduations; L'expansion des caractères. La valeur est la taille désirée de caractères de texte par rapport à la taille du texte par défaut.
# lty : (ligne type) Types de lignes. Le type 1 est toujours une ligne solide, le type 0 : type de ligne toujours invisible, et le type 2 : lignes en pointillés, en petit tiret ou les 2 à la fois.
# lwd : taille des traits
radl = FALSE
locator(n = 512, type = "n", ...)
xtable(sf)
library(shiny); source('Visu_AM/app.R')
runApp()
runApp('Visu_AM')
source('Visu_AM/app.R')
runApp('Visu_AM')
# Define server logic required to draw a histogram ----
source('~/Documents/AM/R_Projects/ArMag/ArMag.R', echo=FALSE)
server <- function(input, output, session) {
# Histogram of the Old Faithful Geyser Data ----
# with requested number of bins
# This expression that generates a histogram is wrapped in a call
# to renderPlot to indicate that:
#
# 1. It is "reactive" and therefore should be automatically
#    re-executed when inputs (input$bins) change
# 2. Its output type is a plot
file.AM <- reactive( input$fileAM )
mes.all <- reactive( read.AM.mesures (file.AM()$datapath) )
mes.sel <- reactive( extract.mesures.specimen.number(input$specimenNumber, mes.all()) )
mes.info <- reactive( read.AM.info (file.AM()$datapath) )
output$filena <- renderText({
if (is.null(file.AM() ))
return(" Choose a file !")
nbMes <- length(mes.info()[,1])
lab <- paste("Quel numéro ? max =", nbMes)
updateNumericInput(session, "specimenNumber", label = lab,  max = nbMes   )
#paste("fichier:", file.AM$name, " path:", file.AM$datapath)
paste("fichier:", file.AM()$name)
})
output$mytable = DT::renderDataTable({
if (is.null(file.AM() ))
return(NULL)
if (input$rbGraph == "ttani" || input$rbGraph == "ttflin") {
res.list <- mes.all()
} else {
res.list <- mes.sel()
}
if (input$cbSuppAni == TRUE) {
etape.sigle <- c("Z+", "Z-", "X+", "X-", "Y+", "Y-", "ZB")
ani.etape <- trimws(paste(as.character(input$aniValue), etape.sigle, sep = "") )
selec <- NULL
for (i in 1:length(ani.etape)) {
selec <- c( selec, which(trimws(res.list$Etap) == trimws(ani.etape[i])) )
}
if (length(selec) > 0)
res.list <- res.list[-selec,]
}
res.list
})
output$textFile <- renderPrint({
if (is.null(file.AM()))
return(NULL)
# Lecture et Copy du fichier
lin<- NULL
fil <- file(file.AM()$datapath, "r")
lin <- readLines(fil, encoding="latin1")
close(fil)
lin
})
output$distPlot <- renderPlot({
if (is.null(file.AM() ))
return(NULL)
res.list <- mes.sel()
if (input$cbSuppAni == TRUE) {
etape.sigle <- c("Z+", "Z-", "X+", "X-", "Y+", "Y-", "ZB")
ani.etape <- trimws(paste(as.character(input$aniValue), etape.sigle, sep = "") )
selec <- NULL
for (i in 1:length(ani.etape)) {
selec <- c( selec, which(trimws(mes.sel()$Etap) == trimws(ani.etape[i])) )
}
if (length(selec) > 0)
res.list <- mes.sel()[-selec,]
}
if (input$rbGraph == "assemble") {
par(mfrow = c(2,2),  mai = c(0, 1, 0, 0), oma = c(0, 0, 3, 0) )
plot.zjiderveld1(res.list, legend.pos = "topright", main = "")
plot.zjiderveld2(res.list, main = "")
plot.lambert.XYZ.specimen(res.list, main = "")
plot.desaim(res.list, main = "")
mtext(as.character(res.list$name[1]), outer = TRUE, cex = 1.5)
}
if (input$rbGraph == "lambSpe")
plot.lambert.XYZ.specimen(res.list)
if (input$rbGraph == "zijd1")
plot.zjiderveld1(res.list)
if (input$rbGraph == "zijd2")
plot.zjiderveld2(res.list)
if (input$rbGraph == "desaim")
plot.desaim(res.list)
#plot.desaim(mes.all())
if (input$rbGraph == "ani") {
Data <- anisotropie.tensors.numbers(input$specimenNumber, mes.all(), mes.info(), input$aniValue)
plot.lambert.ID.tensors(Data)
}
if (input$rbGraph == "ttani") {
Data <- anisotropie.tensors.all(mes.all(), mes.info(), input$aniValue)
plot.lambert.ID.tensors(Data)
}
if (input$rbGraph == "ttflin") {
Data <- anisotropie.tensors.all(mes.all(), mes.info(), input$aniValue)
plot.flin(Data)
}
}, height = 700)#, width = 500)
output$info <- renderPrint({
if (is.null(file.AM() ))
return(NULL)
if (input$rbGraph == "ttflin") {
Data <- anisotropie.tensors.all(mes.all(), mes.info(), input$aniValue)
#nearPoints(Data, input$plot_click, xvar = "F23", yvar = "F12")
brushedPoints(Data, input$plot_brush, xvar = "F23", yvar = "F12")
} else {
return(mes.info()[input$specimenNumber,])
}
})
}
runApp('Visu_AM')
runApp('Visu_AM')
runApp('Visu_AM')
# Define server logic required to draw a histogram ----
source('~/Documents/AM/R_Projects/ArMag/ArMag.R', echo=TRUE)
runApp('Visu_AM')
runApp('Visu_AM')
runApp('Visu_AM')
runApp('Visu_AM')
runApp('Visu_AM')
runApp('Visu_AM')
runApp('Visu_AM')
source('Visu_AM/app.R')
source('Visu_AM/app.R')
source('Visu_AM/app.R')
runApp('Visu_AM')
Encoding(base)
runApp('Visu_AM')
runApp('Visu_AM')
runApp('Visu_AM')
runApp('Visu_AM')
runApp('Visu_AM')
runApp('Visu_AM')
runApp('Visu_AM')
runApp('Visu_AM')
runApp('Visu_AM')
runApp('Visu_AM')
runApp('Visu_AM')
runApp('~/Documents/AM/R_Projects/ArMag/Visu_AM')
source('~/Documents/AM/R_Projects/ArMag/Visu_AM/app.R')
